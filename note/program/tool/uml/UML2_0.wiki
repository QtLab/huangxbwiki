=== 6.5.1 是参与者特殊化 ===
* 参与者可以使另一个参与者特殊化(specialize, 继承它的行为). 这会给系统用例模型添加更多的表达方式. 例如, 可以把顾客设计为抽象的概念, 会员应根据该概念进行特殊化; 一旦引入了特殊化, 引入非会员的概念就是有意义的.(一般化继承生成特殊化)
* 客户必须理解我们生成的制品, 至少要理解从业务建模到静态分析的正确方式.
{{{
	案例分析
	iCoot 带继承的系统参与者表
	决定给iCoot参与者引入继承后, 完成的系统参与者表如下所示(其中多了一个参与者, 继承关系放在括号中):
		* 顾客: 使用 Web 浏览器访问iCoot的人.
		* 会员: 在一家商店提供了姓名, 地址和信用卡信息的顾客; 每个会员都有一个Internet密码和一个会员号.(特殊化顾客)
		* 非会员: 不是会员的顾客.(特殊化顾客)
		* 助手: 商店的一个员工, 他与会员联系, 告诉他们预约的进展情况.
}}}
* 可以修改用例图, 显示参与者之间的继承关系.
=== 6.5.2 用例的关系 ===
* 除了参与者之间的特殊化以及参与者和用例之间的关系外, 用例之间的关系还有特殊化(specialize), 包含(include), 扩展(extend). 这些关系可以组合相关的用例, 分解大的用例, 重用行为, 指定可选的行为.
	- 特殊化: 用例也可以相互继承. 可以只特殊化抽象的用例. (纯)抽象用例根本没有步骤, 其唯一目的是组合其他用例. 如: "U1:浏览索引"和"U4:搜索"都是抽象用例"U13:查找汽车模型"的变体.
	- 包含: 如果第一个用例有一些第二个用例提供的步骤, 该用例就包含第二个用例. 如"U1:浏览索引"在其行为的某个地方包含了"U2:查看结果"的全部步骤. 
	- 扩展: 第一个用例给第二个用例增加步骤, 就成为扩展第二个用例. 例如, 查看结果(U2)时, 顾客可以选择查看细节(U3). 扩展关系可以增加可选的额外步骤--通常这些额外步骤位于用例的末尾, 也可以位于用例的开头或中间.
* 包含与扩展的区别: 包含中, 源用例没有目的用例就不能工作, 扩展中, 源用例没有目的用例也能工作. 
{{{
	案例分析
	iCoot用例的关系
	用例描述现在如下所示。抽象用例和关系的两端都标识清楚了-----基本原则是，看一下表示法，读者就知道需要查看其他用例，才能完整地理解该用例。
		- U1:浏览索引：顾客浏览汽车型号的索引(特殊化U13，包含U2)。
		- U2:查看结果：给顾客显示检索到的汽车型号子集(被U1和U4包含，被U3扩展)。
		- U3:查看汽车型号的细节：给顾客显示检索到的汽车型号细节，例如描述和广告(扩展U2，被U7扩展)。
		- U4:搜索：顾客指定类别、构造和引擎规格，搜索汽车型号(特殊化U13，包含U2)。
		- U5:登录：会员使用会员号和当前密码登录iCoot(由U6、U8、U9、U10和U12扩展)。
		- U6:查看会员信息：会员查看iCoot存储的会员信息子集如姓名、地址和信用卡信息(扩展U5)。
		- U7:进行预约：会员在查看汽车型号的细节时，预约一种汽车型号(扩展U3)。
		- U8:查看租用情况：会员查看当前租用的汽车汇总信息(扩展U5)。
		- U9:修改密码：会员修改用于登录的密码(扩展U5)。
		- U10:查看预约情况:会员查看还没有结束的预约汇总信息，例如日期、时间和汽车型号(扩展U5，被U11扩展)。
		- U12:注销：会员从iCoot中注销(扩展U5)。
		- U13:查找汽车型号：顾客从目录表中检索汽车型号的子集(抽象，被U1和U4般化)。
}}}
* 用例之间的继承关系以正常方式显示, 即用带有白箭头的线条. 包含关系显示为箭头开放的虚线, 从包含的用例指向被包含的用例, 并标记上关键字<<include>>. 扩展也显示为箭头开放的虚线, 从扩展的用例指向被扩展的用例, 并标记上关键字<<extend>>.
* 某些情况下, 扩展关系只能在某些条件具备的情况下存在. 我们可以添加UML注释, 其为任意文本, 在图中用虚线连接相关的点, 终点为一个小圆圈. UML中的条件表示为约束(constraint). 可用自然语言, 伪代码, 或者UML的正式对象约束语言(Object Constraint Language, OCL)表述.
{{{
	案例分析
	iCoot用例调查(完整)
	任何顾客都可以浏览汽车型号索引(U1)或通过搜索(U4),在目录中查找汽车型号。在后一种情况下，顾客要指定他们感兴趣的类别、构造和引擎规格。无论采用哪种方式，在每次检索后，都会给顾客显示匹配汽车型号的集合(U2)，以及基本信息，例如汽车型号的名称。然后， 顾客就可以选择查看特定汽车型号的其他信息，例如描述和广告(U3).
	顾客有两种情况：会员和非会员.
	已成为会员的顾客可以登录(U5)，访问额外的服务。额外的服务有进行预约(U7)，取消预 约(U11)，检查会员信息(U6)，查看已有的预约(U10)，修改登录密码(U9)，查看已有的租用记 录(U8)和注销(U12)。
	助手涉及到预约的整个过程，例如把汽车开进开出保留区域，
	浏览索引和搜索汽车型号是查找汽车型号(U13)的两种不同方式。为了查看汽车型号的细节，顾客必须查看搜索型号的结果(通过浏览或搜索路径)。
	为了预约汽车型号，会员必须查看其细节(非会员不能预约，即使他们在查看细节也不行)。
	= 要取消预约，会员必须查看已有的预约。 =
}}}

=== 6.5.3 系统用例的细节 ===
* 这里的四个用例细节使用以自然语言编写的一系列步骤. 也可以根据个人喜欢添加更符合算法的结构, 例如条件和循环(例如 if-then-else 和 repeat-until).
* 在编写用例的细节时, 必须指定系统的功能, 而不是指定交付功能的方式. 例如, 如果要包含步骤"2. 顾客单击 Detail...按钮", 就要限定用户界面的设计人员. 除非这是绝对要求, 否则就应总是使用中性词与, 例如选择, 启动, 指出和显示.

=== 6.5.4 前提条件, 后置条件和继承 ===

=== 6.5.5 辅助需求 ===
* 大多数情况下, 可以把非功能需求关联到特定的用例上. 例如, 非功能需求"广告应使用流协议显示, 而不需下载"比较适合"U3:查看汽车型号的细节".

=== 6.5.6 用户界面草案 ===
* 为系统考虑用户界面有助于阐明用例. 界面可在早期阶段与客户一起讨论, 并把结果记录为用户界面草案(user interface sketches). 这些草案应看为基本指南, 而不是专业的GUI设计, 有助于标识和分解能根据个人喜好来实现的功能.
* 这些草案为经过讨论通过, 使用绘图软件包仿制的版本.
* 在每个用户界面中, 都应提供对应各个用例的窗口或面板.

=== 6.5.7 系统用例的优先级 ===
* 实际上, 用例的优先级(紧急程度)不仅取决于期望, 还取决于在当前的递增开发过程中为各个用例投入的系统体系结构和编码工作量.
* 给系统用例分配优先级和紧急程度还说明, 应为扩展性和重用性进行开发.

= 第7章 分析问题 =
== 7.1 引言 ==
== 7.2 为什么要进行分析 ==
* 不可能仅根据业务需求模型就完全理解问题
	- 因为业务需求模型描述了已有的实现, 只有添加软件, 才可能引入新的实现. 
	- 另外, 手工工作流和自动(或潜在自动)工作流不是分开的; 例如, 预约汽车型号涉及到人与人和人与计算机的交互操作. 
	- 这些用例关注的是外部. 用例处理的是参与者和系统边界之间的交互操作----系统本身是一个黑盒子, 嗲有外部才能看到的接口. 
	- 用例是不严密的; 为了使系统更容易开发和理解, 用例是用自然语言编写的, 因此它们依赖编写人员对语言的理解和作出的某些假设.
* 当然, 业务需求建模和系统需求建模仍必须完成, 前者可以用于理解业务上下文, 后者能用于与客户达成协议.
* 静态分析之后可让客户确认我们对业务对象的理解是否正确, 之后让对象影响我们的设计. 动态分析之后, 可以确信分析对象能够支持需要的系统功能.

== 7.3 分析过程概述 ==

== 7.4 静态分析 ==

=== 7.4.1 确定类 ===

=== 7.4.2 标识类的关系 ===
* 这些关系出现的频率如下: 关联 > 聚合 > 继承 > 复合

=== 7.4.3 绘制类图和对象图 ===
* 类图显示了存在哪些类, 这些类有什么关系(正式的类图还可以显示属性和操作). 对于聚合, 复合和关联, 类图显示了允许的运行时关系, 而不是显示实际的运行时关系.
* 类名应显示为粗体. 如果类是抽象, 其名称就显示为斜体, 如手工标记抽象类, 在上面或左边加上关键字{abstract}.
* 对象标签是有下划线的.
* 对象图对于演示某个运行期间的情况很有用, 但它们是可选的.

=== 7.4.4 绘制关系 ===
==== 1. 多重性 ====
* 对于复合, 复合端的数字总是1, 因为根据UML规则, 复合的对象不能在复合体中共享, 因此, 在这种情况下, 数字1就是多余的. 在其他情况下, 如果没有显示数字, 就必须假定没有指定它, 或者在这个阶段, 该数字是未知的. 假定某个遗漏的数字隐含着某个默认值(如1)是错误的.
{{{
	在图7-7中，可以推断出：
	* Car 有—个 Engine。
	* Engine 是 Car 的一部分。
	* Car 有 4 或 5 个 Wheel。
	* 每个Wheel都是Car的一部分，
	* Car总是由一个Body组成。
	* Body总是Car的一部分，它随着Car—起消亡。
	* Car可以有任意多个Driver。
	* Driver至少可以驾驶一辆Car。
	* Car在某一时刻至多有7位Passenger。
	* 一位Passenger在某一时刻只能在一辆Car上。
}}}
* 复合的对象不能同时是两个对象的一部分, 即使复合的对象是独立的, 复合体本身被删除时, 就要删除复合的对象, 这会强制共享.
* UML禁止先创建复合的对象, 再把对象传送给复合的构造函数.
* 当有明显的部分-整体关系时, 最好使用聚合, 复合应用于有明显的共享生存期的情形.
* 从设计的角度来看, 要在内部隐藏委托对象, 而不是从另一个类中集成, 以便给对象添加行为时(例如之前的Stack和LinkedList), 复合也是很有用的.
* 从实现的角度来看, 一对多和多对多关系常常需要在运行期间使用集合对象(列表, 树, 集等), 例如, Car可以使用某种List对象来处理其乘客.

==== 2. 关联标签, 角色和注释 ====
* 除继承之外的所有关系都可以给定一个关联标签, 它表示关联的性质.

=== 7.4.5 属性 ===
* 如果这个阶段不能为属性提供简短的描述, 该属性就应分拆为几个属性, 甚或自成一类.
* 在设计阶段, 使用数组可能比较多, 但仍需要小心, 不要因为改进性能而牺牲好的样式.
* 就UML而言, 属性和关联(所有三个变体)都只是类的属性. 换言之, 每个属性都可以显示为属性, 或者显示为把属性名作为角色的关联(把原型值或数组作为关联会很奇怪, 所以一般只作为属性). 这意味着, 可以在类型名的后面给属性添加多重性, 例如*表示多值属性, [0...1]表示可选属性.

=== 7.4.6 关联类 ===
* 关联类可以和关联一起引入, 如图7-13. 一个CarModel可以与任意多个Customer对象关联, 一个Customer也可以与任意多个CarModel对象关联. 对于每个链接, 都有一个对应的Reservation对象, 它包含号码, 时间戳, 状态. 本例没有给关联指定名称, 因为它隐含在关联类Reservation的名称中. 
* 关联类表示关联的信息或行为.
* 关联类表示的属性和操作仅因为关联类存在而存在, 属性和操作与关联两端的对象都无关. 例如, 顾客预约时, 在运行期间Customer和对应CarModel之间建立一个新链接, 在需求捕捉和分析阶段, 必须记录下预约号, 时间戳和状态. 但这些属性对Customer和CarModel都没有什么意义, 它们位于这两个对象之间, 所以使用关联类比较合适.
* 设计时用更具体的类代替关联类.

=== 7.4.7 有形对象和无形对象 ===
* 一般, 每种无形对象有许多有形对象.
* 把有形产品和无形产品只建立为一个对象是一个常见的错误. 例如, 汽车经销商的销售系统. 图7-14中, 其中只建立了一个汽车对象, 但是实际上有两个"汽车"概念, 目录表中的汽车是无形的, 它描述了该类型的所有汽车的特性, 但这种汽车可能还不存在. 而顾客拥有的汽车是有形的, 它肯定存在, 因为它可以驾驶, 与另一个顾客拥有的同类型汽车是不同的.
==== 1. 错误的建模 ====
* 图7.17, 选择A则有一半的属性没用, 选择B, 则每个对象只能为一辆"Alpha Rodeo 156 2.0"型汽车提供服务.
* 可以看出, 无形的汽车类型可用于一般化. 具体的汽车则可用于每个顾客的服务.

==== 2. 正确的建模 ====

=== 7.4.8 好的对象 ===
* 建议在动态分析之前不要过多地关注操作, 但及时记下操作是没有什么害处的.

== 7.5 动态分析 ==
=== 7.5.1 绘制用例的实现过程 ===
* 在通信图和顺序图中都可以记录相同的信息, 但通信图更适合于用例的实现, 因为通信图更容易生成, 而且它们关注的是对象及其连接, 而不是消息传送的顺序.
* 这里可以不使用双向交互, 而使用更面向计算机的客户-提供商模式: 参与者启动与边界对象的交互; 对象边界启动与系统对象的交互; 系统对象启动与其他系统对象, 其他系统边界的交互.

=== 7.5.2 边界, 控制器和实体 ===
* 清晰的通信图把对象显示为带标签的方框. 为了表达额外的信息, UML允许开发人员使用图表来代替方框, 表示对象的特性. 见图 7-22.

=== 7.5.3 通信中的元素 ===

=== 7.5.4 给类添加操作 ===

=== 7.5.5 职责 ===
* 只要发现系统需要的信息或行为, 就应思考"哪个对象负责这个信息或行为?", 信息最终以属性(和对象)的方式出现, 行为最终以操作(和协作)的方式出现.
* 双向协作比较复杂, 难以维护. 提供者相对于其客户而言是松耦合. 双向协作会在两个方向上产生强耦合. 本书描述的每个用例的实现都把参与者当作与边界交互的启动者, 而边界又会与实体通信, 这有助于生成客户和提供对象. 当然, 深入系统就会发现, 提供者也可能是一个客户, 客户也可能是一个提供者.

=== 7.5.6 状态建模 ===
* 有时实体的生存期非常复杂, 需要显示在状态机图上. 例如, 图7-25显示了iCoot中Reservation的复杂生存期模型. 
* 在Reservation创建后, 就处于等待状态, 一旦达到Conclude状态, 在系统中就不再担任任何任务.
* 图7-25 用于预订的状态机图的完整描述---状态机调查.
{{{
	当会员通过Internet预约汽车型号时，Reservation就等待助手来处理(所以顾客可以在没有助手的帮助下进行预约)。如果以后的某个时刻助手发现在停车场的显示区域中有一辆合适的、未预约的汽车，或者顾客返还了一辆汽车，Reservation就变成Notifiable。此时，汽车移动到保留区域。
	如果在一星期内都没有给某个Reservation提供汽车，该Reservation就变成NeedingRenewal:必须电话或亲自通知会员，让他们取消预约，或在下周重新领约。如果会员取消了预约，或在五天内联系不上，Reservation就变成Concluded。
	一旦Reservation变成Notifiable,助手就必须在三天内电话或亲自通知会员。如果联系上顾客，Reservation就变成Collectable,否則就变成Displayable(移动到保留区域的汽车必须返还到显示区域)。
	一旦Reservation变成Collectable，会员就必须在三天内取车；如果会员取了车Reservation 就变成Concluded,否则就变成Displayable。
	一旦Displayable Reservation的汽车返还到显示区域，Reservation就变成Concluded。
	会员可以在任何时候通过Internet电话或亲自取消预约。
	系统会告诉助手当前预约的状态(还未结束)，这样助手就可以采取适当的措施。
}}}

= 第III部分 设计解决方案 =

= 第8章 设计系统体系结构 =
== 8.1 引言 ==
* 分析和设计之间有清晰的分界比较好, 可以确保在考虑解决方案之前, 很好地理解问题.
* 把分析模型转换为设计模型并没有硬性规则. 
* 我们不关心分析对象和设计对象之间是否有严格的对应关系, 只要设计可以得到有效的解决方案即可.
* 设计越通用, 与特定技术的关系就越小---这会减少开发人员精通多项技术的需求, 防止使用已废弃或得不到支持的技术. 通用化的缺点是不能从特定技术中获得最大利益.

== 8.2 设计优先级 ==
* 用例优先级是有帮助的, 用例紧急程度也是有帮助的, 后者在需求阶段使用交通灯来模拟: 绿灯必须完全设计好; 黄灯不必设计, 但必须支持; 红灯禁止设计, 但仍应支持("设计"表示确定解决方案, "支持"表示可能找出合理的解决方案, 这需要进行一些预测).

== 8.3 系统设计中的步骤 ==
* 系统设计注重于从较高的层次来考察任务, 之后进入子系统的设计(第10章).
* 系统设计包括如下活动:
	- 选择系统拓扑
	- 选择技术
	- 设计并发策略
	- 设计安全策略: 例如, 考虑顾客的个人数据---必须确保这些数据不被罪犯盗走, 确保数据不会无意展示给其他客户.
	- 选择子系统部分: 开发一个解决所有问题的系统常常是不切实际的, 我们需要开发若干个软件, 然后确保这些软件可有效地通信. 
	- 把子系统分解为层或其他子系统
	- 决定机器, 子系统和层如何通信

== 8.4 选择联网的系统拓扑 ==
=== 8.4.1 网络体系结构的简史 ===
=== 8.4.2 三层体系结构 ===
* 在三层系统上, 任何程序都至少涉及三台机器.
* 三层体系结构的优点如下:
	- 分解重要的部分: 任何大型系统都必须考虑安全性, 大量数据的有效管理, 高吞吐量的编程逻辑和简单的用户界面. 为这些部分单独编程, 开发人员的工作就较容易完成, 并可以优化每个部分的设计.
	- 使用正确的机器完成工作: 并没有什么适合一切工作的计算机. 运行用户界面是一个简单的工作, 不需要大型机, 甚或文件服务器; 执行编程逻辑要使用大量的CPU和内存, 但不需要巨大的磁盘空间, 所以可以使用强大的服务器; 管理大量数据(例如一百万电子顾客)需要目前所有的计算能力和磁盘空间, 所以这需要大型服务器或大型机.
	- 改进性能: 可以在数据层或中间层复制适当的机器, 将计算负载分散开(负载平衡, load balancing), 每一层都专业化, 以便于优化.
	- 改进安全性: 三层系统在部署时, 常常使客户机在互联网上运行. 因此, 必须有一个严格的安全策略来保护内部机器, 程序和数据. 在三层体系结构中, 可以确保中间层的安全---阻止外部的无意或恶意攻击. 数据层在防止破坏的中间层的后面, 所以不必保护其通信或硬件; 这意味着数据层更容易编程, 运行也较快.
	- 保护投资: 中间层可以看作大型机的客户, 以及真正客户的服务器. 这样就可以把原来的系统转换为现代系统.
	- 灵活: 除了能随意增加和减少机器之外, 如果用三层体系结构设计系统, 部署也会非常灵活. 例如, 只要逻辑分区是正确的, 就可以在一层上开发系统, 然后部署到三层, 二层(中间层和数据层合并起来)或一层(所有三层都合并在一起)上.
	- 可以容纳不同类型的客户: 客户层机器只需接受用户的输入, 显示系统的结果, 所以可以为不同类型的设备(个人计算机, PDA, 机顶盒, 移动电话等)提供不同的界面. 中间层和数据层在所有设备上的工作不会有变化.
=== 8.4.3 个人计算机 ===
=== 8.4.4 网络计算机 ===
=== 8.4.5 互联网和万维网 ===
=== 8.4.6 内联网 ===
* 内联网 --- 运行在封闭环境下的"微型互联网". 
* 对于大多数内联网, 都可以达到本地的性能, 有安全优势, 还允许员工访问互联网. 为此, 需要使用互联网防火墙.
=== 8.4.7 外联网和虚拟私人网络 ===
* 如何利用内联网的性能优势和安全优势进行业务对业务的通信? 使用外联网(extranet), 这是一个或多个内联网之间的安全连接. 是"外部内联网"的简称. 建立外联网最简单的方式是, 在每个内联网的边界上运行互联网防火墙上的一个软件, 它执行两个任务:
	- 允许信息在防火墙之间传送.
	- 使用强大的加密技术保护在互联网上传送的信息.
* 外联网也成为虚拟私人网络(Virtual Private Network, VPN). 
=== 8.4.8 客户机-服务器与分布式体系结构 ===
* 只要连接多台机器或多个软件系统, 就必须在客户机-服务器与分布式体系结构中选择. 
	- 客户机-服务器: 大量小型的简单客户机给几个大型多线程的服务器发送请求, 服务器会处理这些请求.
	- 分布式(或等对 peer-to-peer)体系结构的特点是, 一组独立的对等机器根据需要在任意方向上通信.
* 客户机-服务器体系结构最常见的例子是电子商务模型: 顾客的Web浏览器给公司的Web服务器发出请求, 公司的Web服务器给后端系统发出命令. 大多数二层和三层系统都是客户机-服务器.
* 分布体系结构的一个例子是, 一个繁重的计算任务散步到许多互联网机器上. 如果需要处理非常多的数据或过程, 而且可以分解这些数据或过程, 就可以把它们分布到独立的机器上.
	- 一个例子为 SETI@home, 非盈利组织, 查找外星人无线电信号.
* 术语"客户机-服务器"和"分布式"(或"对等")也用于描述软件体系结构, 独立于软件部署到物理机器和网络上的方式. 运行在程序中的对象就是一个好例子: 正常情况下, 把对象编写为可以在不同环境下重用不同客户机对象的服务器, 但对于特定目的的应用程序, 也可以编写以分布方式写作的环境组.
=== 8.4.9 用UML描述网络拓扑 ===
* 系统体系结构可以用UML在部署图上描述(如图8-6所示). 这个简单的部署图只显示了节点, 通信路径和多重性. 在这个图中, 每个节点都表示一个主机(用UML关键字<<device>>表示). 通信路径表示两个节点以某种方式通信. 节点可以指定多重性, 表示运行期间存在多少个节点; 因此, 在这个图中, 显示了复制的节点(CootServer和DBServer)和繁殖的节点(CootHTMLClient和CootGUIClient).
* 部署图类似于类图和对象图, 因为它们都可以显示可能的体系结构(节点类型)和实际的体系结构(节点实例). 在显示节点实例时, 就像对象图中的对象一样, 节点标签也采用 name:Type格式, 也应加下划线. 
* 如果大多数部署图是有意义的, 就需要附带的描述. 按照Jacobson格式, 这称为部署调查.

== 8.5 并发设计 ==
* 并发的最简单方式是限制系统或引入额外的业务规则, 尤其是当用户的访问次数没有明显减少时, 就更是如此. 例如, 在iCoot中, 在顾客访问汽车目录时, 不应试图更新它, 而可以在一个独立的数据库中更新目录, 每天切换一次数据库. 这样互联网子系统就可以假定该目录是只读的, 从而使代码更容易编写. 这是对系统的人为限制.
* 业务规则也可以使开发人员的工作更容易完成. 实际上, 有时引入业务规则是因为, 没有更好的方法解决问题. 例如, 考虑, 音乐会门票的购买系统. 顾客Fred走进巴黎的预订办公室, 几乎在同时顾客Beryl走近了位于纽约的另一个预订办公室. 两位顾客都决定购买伦敦同一场音乐会的门票, 可惜, 只剩下一张票了. 如何决定谁买到这张票? 两个顾客都在问:"有票吗?" 两个售票员都查看系统, 都回答"有". 现在就有一个竞争; 第一个说"好, 我要一张"的顾客会买到这张票, 这依赖于售货员的效率和从巴黎到纽约到实际服务器位置的网络延迟.
* 为了避免顾客对系统不满, 就可以引入一个额外的业务规则: 当售票员查询是否有票时, 如果有, 就临时保留它---该预订一直持续到售票员取消查询或预订过期(例如, 如果售票员没有取消, 临时预订就持续十分钟)为止. 有了这个新的业务规则, 就可以确保, 只有第一个对票务服务器进行虚拟访问的顾客, 才会被告知有票(票务服务器可以把查询和预订合并到一个业务服务器中).
* 如果并发情况会给系统带来困难, 在确保该情况不会再有问题之后, 再实现并发操作. 要使系统强壮起来, 因为现实是残酷的.

== 8.6 安全设计 ==
* 安全是一个相当宽泛的术语, 可以分解为五个方面:
	- 私密性: 必须隐藏信息, 只有授权的人才能读取它.
	- 验证: 需要知道信息从何而来, 以便决定信任或不信任它.
	- 不能反驳的信息: 这是验证附带的一个功能, 确保信息的初始提供者不能否认它们是信息的来源, 如果事情出错, 这将有所帮助.
	- 完整性: 必须确保信息在从其来源传送给我们的过程中, 不受到无意或恶意的破坏.
	- 安全性: 必须控制对资源(例如机器, 过程, 数据库和文件)的访问. 安全性也成为授权(authorization).
* 在这里, 信息不仅表示数据, 例如业务文档和用户密码, 还表示可执行的代码. 代码是一个问题, 因为它可以通过网络动态加载. 
* 正常情况, 运行一段代码时, 操作系统会对代码要做的工作施加某种控制, 如控制对文件, 目录和其他程序的访问.  操作系统其自身有错误和安全漏洞, 另外操作系统提供的控制是比较死板的.
* 如果系统通过网络来操作, 安全方面就更重要, 这是因为黑客可以劫持运行在机器上的程序.

=== 8.6.1 数字加密和解密 ===
* 数字加密的级别一般表示为位强度(bit strength); 128位加密是目前最低级的加密, 1024位加密是比较理想的.
* 数字密钥基于素数. 密钥本身使用数字证书来发布, 在可信任的证书权威机构的帮助下, 证书可以验证密钥, 这样就不会被黑客欺骗了.
* 下面说明前面四个安全方面如何使用密码技术实现:
	- 私密性: 在数字加密和解密中, 密钥的安全发布是使用公共和私有密钥对, 证书和证书权威机构来实现.
	- 验证：这需要使用证书和证书权威机构证明密钥的来源；粗略说，如果可以成功地解密信息，而且知道密钥的来源，就表示信息必然来自与密钥相同的来源。
	- 不能反驳的信息：验证需要证明密钥的来源，所以，一旦验证了一段信息，这个验证就是不能反驳的。
	- 完整性：首先，把加密的信息和未加密的信息都传送给客户机。然后，客户机解密其中已加密的信息，并把结果与未加密的信息进行比较一显然，两者应匹配(它们不匹配的几率很小)。因此，可以相信接确的信息。
* 上面完整性检查有两个问题: 第一, 发送了未加密的信息; 第二, 信息发送了两次(加密的版本和未加密的版本一样大). 通过安全线路来发送信息, 就可以解决第一个问题. 根据消息摘要进行优化, 就可以解决第二个问题---摘要是使用不可逆算法从信息中生成的一个小位串. 我们发送的是加密的摘要, 而不是加密的信息. 最终结果是进行了相同程度的完整性检查, 但信息只发送一次(为便于记录, 加密的摘要成为数字签名).

=== 8.6.2 一般安全规则 ===
* 下面是保护(联网)系统时要注意的事项:
	- 防止未经授权就访问服务器，无论是无意还是恶意。
	- 界定内部网络的敏感信息：敏感信息包括与其他公司交易的业务信息；业务策略；个人信息；信用引用机构的信息；与国家安全相关的信息等。
	- 防止盗取导出的信息：确保在内联网外部传送的信息只能由指定的接收者读取。
	- 保护员工和顾客的密码，这不仅是整个安全策略的基础，它们还是高度个性化的。
	- 防止服务器代码访问不需要的资源。
	- 防止客户机代码访问不需要的资源：防止未经授权就访问客户的资源，防止客户受到无意的伤害(因为我们希望提供高质量的服务，而不希望客户控告我们)。

== 8.7 分解软件 ==
* 我们可以把软件分解为系统, 如果需要, 在分解为自治的子系统, 最后分解为层(也可以称为子系统).
=== 8.7.1 系统和子系统 ===
* 考虑 Customer 这个概念在公司各个部门如何看待, 如销售,市场,会计,采购,发货等部门. 如果用一个软件系统支持所有这些部门, Customer就会有上百个属性和上百个操作.
* 业务应有许多不同的系统, 每个系统都由不同的开发小组来实现, 这样重用对象不当的机会就会降低到最低. 然后, 信息需要在系统间传送, 就应通过设计优良的接口以定义明确的受控方式来传送. 为了进一步降低复杂度, 每个系统还应分解为各个子系统.
* 图8-7把一个公司的系统显示为树林中独立的树.
* 案例分析中, 有一个系统Coot, 由两个子系统组成: iCoot为会员和非会员提供访问, 另一个子系统为助手提供访问, 且类似于已有的Auk界面.

=== 8.7.2 层 ===
* 在软件系统中, 通常采用代码的多个层(见图8-8). 每一层都是一组合作对象, 它们依赖于底层提供的功能. 层不必包含对象, 例如, Unix系统库通过C函数层提供对底层操作系统功能的访问. 
* 层将实现过程分解为多个可管理的块, 有助于降低复杂度. 层还提供了重用的可能性, 因为每一层的编写都独立于其上的曾.
* 无论层的总数有多大, 最顶层都常常表示用户界面, 最低层表示操作系统或网络连接. 为了简单起见, 省略了最底层, 只显示到一个众所周知的层上, 该层在其他地方介绍.
* 层可以打开(显示下层上的一些对象, 供上面的层使用, 例如管理下层中的对象, 但没有完全隐藏它们); 也可以关闭(完全封装下面的层, 例如上面的层完全靠不到底层的对象). 关闭的层需要更多的编码, 运行更慢. 打开的层不太安全, 较难维护(因为每一层的上面都有多个依赖它的层).
* 某种程度上, 可以交换各个层, 而不会伤害其他的代码. 例如, 去掉最顶层, 用另一个层代替. 而且, 可以用一个有相同接口的层替换关闭的中间层, 而不会影响上面的层.
* 一些技术(第9章详细论述)
	# 单层系统的层
		- 图 8-9 为单层系统采用的一个简单的多层模式.
		- 数据库层任务为在DMBS和业务层之间来回传送数据. 如果一个更简单的系统在文件中存储数据, 数据库层就是一个文件系统, 而不是DBMS.
		- 业务层由实体对象和支持实现的对象组成.
		- 用户界面层包含的对象负责把可用选项显示给用户, 把用户命令和数据传送给业务层, 并显示从业务层传送来的数据.
	# 两层和三层系统中的层
		- 使用网络从运行在客户机上的用户界面到达服务器上运行的业务层.
		- 网络层包含的对象使网络对用户界面来说是透明的.
		- 用户界面只能直接访问服务器对象.
		- 服务器层包含的对象把业务层的使用简化为一组可管理的业务服务.
		- 除了简化客户机之外, 这还可以本地化服务层上的安全措施, 容纳不同种类的客户机, 而不会影响业务层.
		- 对于两层系统, 数据库层, 服务器层和业务层都位于相同的机器上. 对于三层系统, 数据库层横跨网络, 但DBMS隐藏了信息.
		- 如果使用HTML窗体从客户机到达中间(或服务器)层, 用户界面-网络情况就不太清晰. 在这种情况下, 用户界面部分在客户机上(如HTML页面和窗体), 部分在服务器上().
	# 转换层
		- 不同的层有不同的关注点. 
			* 设计用户界面时, 关注的是菜单, 对话框, 笔记本, 窗口, 可用性, 直观性等. 
			* 对于网络, 关注的是协议, 带宽和不同类型的主机. 
			* 服务器上, 关注的是安全, 多线程和通过量. 
			* 业务层上, 其关注可从业务分析中获得, 关注的是抽象, 属性, 多态性, 重用和面向对象建模的其他基础方面. 
			* 数据库层, 关注的是键, 表, SQL, 锁定, 函数依赖性和数据库理论的其他方面
		- 如果直接把这些不同的层连接在一起, 结果会过于复杂和耦合(强耦合, 一个对象的实现与另一个对象的实现紧密相关, 将使代码难以维护).
		- 可以引入额外的层, 作为转换器, 来降低复杂度和耦合性. 转换层对于把业务层(单层系统)或网络层(多层系统)转换为最终用户需要的最低功能尤其有帮助---这种层常常称为控制器. 控制器管理着用户界面与系统其他部分的通信(这非常符合Jacobson的控制器概念). 另一个常见的转换层是所谓的持久层, 它位于业务层和数据库层之间, 去除了业务层对所使用的存储机制的依赖, 以后改变存储机制就比较容易了(例如从文件改为DBMS). 图8-12显示了增加了控制层和显示层的多层系统.

=== 8.7.3 Java层: 应用小程序和RMI ===
* RMI 是一个Java网络协议.
* 这个图中, 用户界面层是使用Swing库实现的. 控制层访问业务服务的所有代码; 这些代码必须隐藏在用户界面对象中, 以后添加的每个新界面(例如移动电话)都要重新实现它. RMI框架提供网络层, 在客户机上访问服务器对象. Java数据库连接(JBDC)库提供数据库层. JDBC允许使用动态或预编译的SQL访问任意关系数据库. 因为有持久层, 所以可以用面向对象的数据库或文件系统代替JBDC, 而不会伤害业务对象.
{{{
	案例分析
	iCoot 层
	为了演示HTML/CGI和服务程序的配置，图8-14显示了用于iCoot的层。
	对于iCoot，没有持久层，因为通过JDBC访问的关系数据库用于在系统的整个生命周期中为系统服务。JDBC层本身由标准Java库中的类提供。对于用户界面，有两种模式：CGI和服务程序、RMI+小程序。对于第一个版本，将在ServletsLayer上使用HTML/CGI和服务程序。对于以后的版本，将使用SwingLayer为桌面提供RMI+小程序机制。小设备，如PDA和移动电话，则使用 MicroLayer, MicroLayer 是使用 Java 2 Micro Edition(J2ME)实现的。
	对于第一个版本，控制层将在JSP的帮助下由服务小程序提供。对于RMI版本，为适当的GUI设计了 ControlLayer。这意味着控制层在HTTP/CGI网络的下面，在RMI网络的上面。在这两种情况下，控制器会转换(或协作)Serverlayer。因此，ServerLayer下面的所有内容都可以不加丝毫修改地重用(ControlLayer也由GUI的两种模式重用）。
}}}
=== 8.7.4 层中的消息流 ===
* 在分层的系统中, 每一层都是该层下面一层的客户. 消息从上面的层流向下面的层, 每个消息都是一个问题(检索某种信息, getAddress)或一个命令(做某个工作的指令, 例如setAddress).
* 如何让上面的层了解下面的层数据的变化.
	- 给上面的层添加信息, 说明哪个命令改变了什么信息. 其会用逻辑上属于下层的信息影响上面的层--使上层的编码更复杂, 使得上层与下层的耦合更紧密.
	- 只要信息有变化, 就让下面的层给上面的层发送消息. 下面的层必须对上面的层有所了解, 才知道哪个对象发送了消息, 所以下面的层会受到上面的层的影响, 使下面的层更复杂, 也使得其与上层耦合更紧密.
==== 1. 事件 ====
* 当发生了某个有趣的事件时, 该层采用某种方式通知上面的层, 而不在两个方向上增加复杂性或耦合性.
* 事件可以是属性事件, 表示事件源的一个属性值发生了变化, 事件也可以是与属性值无关的纯事件.
* 事件源检测事件的发生, 并告知正在监听的人.
* 在分层模式中, 可以在每一层使用事件源向上面一层的监听者广播事件, 达到把信息保存在正确的位置和最小耦合的目的.
* 图 8-17, 显示事件工作原理的通信图
	# ClockUI给Clock发送addClockListener消息, 注册它自己.
	# ClockWatcher在ClockUI上设置警报, 把警报设置传送给Clock.
	# Clock定期给它本身传送tick消息, 最终发现到时候该发出警报了. 此时创建一个ClockEvent(在ClockEventHome的帮助下), 并给出事件的信息(这里唯一的信息是事件源).
	# Clock给ClockUI发送alarm消息, 并把ClockEvent作为参数(事件对象记录事件源, 如果ClockUI监听多个Clock, 就可以确定是哪个Clock在响).
	# 最后, ClockUI向ClockWatcher发出鸣响.
* 通信图上的序号有字母, 这是因为例子中有三个独立的顺序: 添加时钟监听器; 设置时间; 发出警报(只要添加时钟监听器最先发生, 其他两个事件就可以以任意顺序发生多次).
* 时钟必须独立于ClockUI和ClockWatcher来运行. 否则设置警报后, 控制就会返回ClockWatcher, Clock就不能tick.
* 名称作为UML序-号-的一部分说明, 消息依赖于包含相同名称的消息, 但独立于其他消息. 小心使用数字, 仍可以显示独立消息的书匈奴, 例如, 消息2b在消息3c之前发生. 消息99x和99y同时发生.
* 闹钟的类图如图8-18所示(为了简单起见, 省略了ClockEventHome和ClockWatcher). 从这个图中可以看出, ClockEvent是source属性的获取器, ClockUI的一个消息setAlarm允许ClockWatcher设置警报, 另一个消息alarm可以检测警报事件. 最后, Clock类的一个消息setAlarm用于设置警报, 另一个消息 addClockListener用于注册监听者. 
* 面向对象的语言一般不必有真正的广播机制, 所以图8-18中的Clock必须维护监听者的内部列表, 当发生事件时, 还必须给每个监听者发送消息. 监听者必须确保它们为事件进行了注册. Clock现在和ClockUI耦合在一起, 这是我们应避免的. 为了解决这个问题, 可以引入一个抽象类 ClockListener, 它只列出检测Clock事件所需的消息. 只要ClockUI继承了ClockListener, 就可以用Clock注册ClockUI, ClockUI也可以接收alarm消息. 因此, 即使Clock和ClockListener耦合在一起, 也不与ClockUI耦合在一起. (ClockListener位于与Clock相同的层上, 而ClockUI在该层的上面).
* 用<<interface>>关键字表示的接口是一个纯抽象类, 这种类没有具体的方法, 也没有属性. 接口可以用降低了的耦合性指定通信, 所以在图8-18中有一些特殊的UML表示法. 虚线白箭头(标记为"实现")表示继承, 特殊情况下, 超类是一个接口. ClockListener表示法标记为"提供的接口/需要的接口", 它允许表示一个类通过特定的接口使用另一个类. 本例中, 看起来像棒棒糖的部分表示ClockUI实现(一种)ClockListener, 而辈子形状的部分表示Clock只依赖于ClockUI是一种ClockListener这一点. 
==== 2. 使用事件的消息流 ====
* 一般的消息都是在层中向下流动, 而事件消息是向上流动的.(事件消息显示为虚线箭头, 表示下面的对象对接收者一无所知).
* 客户代码常使用事件, 用户界面用下一层的信息更新的简便方式. 事件很少在服务器端使用, 因为服务器代码是多线程的, 会显著增加事件驱动的编程的复杂性(例如, 出现死锁的可能性会增加). 事件不应通过网络来广播; 在给许多客户发送事件消息时, 如果一些客户已损坏或很难联系上, 就不希望服务器阻拦. 因此建议避免在服务器端进行事件驱动的编程. 如果要通过网络来广播, 应使用机器对机器的消息传输方式, 例如Java Messaging Service(JMS)提供的方式.

= 第9章 选择技术 =
== 9.1 引言 ==
* 即使有了完整的需求和分析文档, 甚至有了最初的体系结构图, 仍无法选择要使用的实现技术. 如前所述, 这个决策拖的时间越长, 系统对未来变化的敏感程度就越小. 另一方面, 在选择技术之前等待的时间越长, 利用这些技术的优点的机会就越小.
* 在开发的这个阶段(详细设计之前), 选择技术是一个很好的折衷方案. 一旦做出了决策, 就可以做出正确的选择, 同时确定对特定技术的独特特性的依赖程度.

== 9.2 客户层技术 ==
* 下面看看在多层系统上运行在客户机上的软件(本书的重点)。主要有两个选择：可以加载特定目的的应用程序(程序、可执行代码，也可以是其他名称)或驻留客户软件的Web浏览器。可以运行的客户应用程序有：
	- 人对人的通信：电子邮件、即时消息传输、USENET新闻、聊天
	- 文件传输或文件交换 
	- 远程登录
	- 专用应用程序(不适合更一般的类别，例如多用户飞行模拟器）
* 驻留在Web浏览器上的客户可以使用如下技术：
	- HTML窗体
	- JavaScript
	- 专用插件(不适合更一?般的类别，例如使用Flash的交互式动画）
	- ActiveX 控件
	- Java小程序
* 上述技术都使用某种协议(例如电子邮件使用IMAP, 即时消息传输使用AIM, HTML窗体使用HTTP/GUI)与至少一个机器(邮件服务器、消息传输服务器或Web服务器)通信。
* 一般说来，应用程序和浏览器插件可以用任意语言编写(Java、C++, Eiffet、Fortran或COBOL)。
* 对于用Java编写的大型客户层, 通过网络加栽小程序是不切实际的——在这种情况下，需要在本地安装小程序(或Java应用程序)。
* 不要通过互联网加栽大程序：如果 通过内联网加载程序，应确保该程序不是特别大(<2MB)。
* 瘦客户GUI可以压缩为100KB的Java小程序，它甚至可以在互联网上加载。 
* 每个浏览器技术都有其优缺点。例如：
	- HTML有非常丰富的可视化效果，获得了广泛的支持，但HTML窗体是比较初始的，不能自动在客户机上验证。另外，人们必须在数十个页面(不同的操作界面)上査看信息，而且在绘制页面前，每个页面都要显示为空白，这不是交互的最佳方式。
	- JavaScript允许一些客户端的编程(例如HTML窗体上的数据验证)。但JavaScript是解释性的(所以比编译性的技术慢)，不纯粹(从面向对象的观点来看)，不同的浏览器提供不同级别的支持(导致编码困难).
	- 理论上，插件可以提供任意类型的客户交互。但是，插件常常需要先下载和安装， 才能使用；每个插件都需要不同的编程技巧，提供者必须为每个新平台(搡作系统/CPU 组合)移植插件，所以，不是每个客户都支持它们。
	- ActiveX控件是位于Web浏览器上的32位Windows 二进制代码，这使ActiveX控件具有和插件与Java小程序一样的优点，但它们只能运行在Windows上。
	- Java是一种简单、纯粹、面向对象的语言，提供了最佳的解决方案。Java还提供了安全措施，当用户没有显式、详细的授权时，它阻止用户访问本地机器上的资源。这部分因为有太多的合作诈骗.在编写本书时，大多数Web浏览器只支持Java的旧版本。要获得Java的完全版本，需要Sun提供的Java插件(Java化装为一个浏览器插件)，或者需要购买预装了 Java的PC。
* 把三层系统移植到新设备上, 一般只需要重新设计用户界面, 使之更小(更原始).

== 9.3 客户层到中间层的协议 ==
* 客户软件无论是作为应用程序运行，还是在Web浏览器上运行，都必须使用某种协议与服务器通信。
* 大多数协议都是分层的：
	- 在底层有一个底层协议, 例如TCP/IP,在顶层，要建立更多的协议，专门用于特定的任务。
	- 在TCP/IP的顶部，可以放置加密和解密信息的安全套接字层(Secure Sockets Layer，SSL),以保证私密性和完整性。
	- 在SSL的顶部，可以运行安全HTTP(Secure HTTP, HTTPS),这是一个安全协议，允许客户通过URI请求文档，得到该文档的内容。
* Java有一个机制，叫做远程方法调用(Remote Method Invocation, RMI),它允许对象给运行在不同机器上的另一个对象发送消息---消息使用Java远程方法协议(Java Remote Mothod Protocol, JRMP)发送。为了通过互联网防火墙，RMI准备在需要时背负HTTP。所以，当一个对象给另一个对象发送RMI消息时，会得到如图9-1所示的运行时情形---图9-1说明一个消息使用JRMP编码，接着使用HTTP,然后是SSL,最后是TCP/IP; 在服务器端，给消息解包，发送给接收者。回应通过相反的路径发送回来。
* 常用的协议分为两类：专用协议和通用协议。专用协议包括：
	- IMAP(电子邮件）
	- AIM(AOL即时消息传输>
	- NNTP(USENET 新闻）
	- HTTP/CGI(HTML 窗体）
	- FTP(文件传输）
	- Telnet(远程登录）
* 通用协议(适用于许多任务)包括：
	- TCP/IP(低级传输，也称为套接字)
	- JRMP(用于Java对Java的通信）
	- HOP(用于CORBA通信，类似于RM1,但有多种实现语言）
* 开发人员常常使用运行时系统和库的高级抽象。例如，RMI和CORBA程序员只给对象发送消息，RMI和CORBA代码完成所有的打包和解包任务。HTML窗体的程序员只设计窗体的布局，公共网关接口(Common Gateway Interface, CGI)机制负责把窗体数据传送给服务器上的可执行代码。

== 9.4 中间层技术 ==
* 服务器应用程序一般是多线程的代码，是为高通过量(能同时处理上千甚至上百万个客户)设计的。服务器应用程序监听某些客户连接(connect)的端口(port,连接点)。
* 在(中间层)服务器上，可以运行独立的应用程序，或者运行Web服务 器，把代码放在Web服务器上。
* 独立的应用程序包括：
	- 邮件、消息传输、新闻和聊天服务器
	- FTP后台程序
	- Telnet后台程序
	- RMI注册表(RMI对象的査找机制）
	- CORBA命名服务(CORBA对象的査找机制）
	- Java命名和目录接口(JNDI)服务器(通用的命名映射服务，可以用于替代RMI注册表、 CORBA命名服务、用户注册表等）
	- 专用服务器(例如，驻留CORBA或RMI对象的过程、EJB客户程序、.NET客户程序） 
* 可以驻留在Web服务器上的服务器代码包括：
	- Java Server Pages(JSP).用于随时建立 Web 页面
	- Active Server Pages(ASP),类似于 JSP,但编码一般是 Visual Basic,而不是 Java
	- CGI脚本(这些可以是解释性的文件，用PERL等语言编写，或者是可执行的程序）
	- 服务小程序(Java服务器对象，可以由Java小程序、JSP或HTML窗体访问）

== 9.5 中间层到数据层的技术 ==
* 中间层调用一些代码之后, 开始访问数据层, 下面是具体方式:
	- 在中间层上包含数据库一客户代码，以便访问运行在数据层上的DBMS。一般使用 Java,可以在Java数据库连接(JDBC)机制的帮助下访问DBMS。
	- 使用前面讨论的任一种客户一中间层技术与数据层通信。毕竟就数据层而言，中间层只是另一个客户。
	- 做一些专门的工作，例如访问运行在数据层机器上的服务器，或直接在中间层上运行代码(二层配置)。
	- 使用非TCP/IP协议访问数据层(通常只有在访问旧系统时才这么做)。
	- 在中间层服务器上包含Enterprise Java Beans(EJB)客户代码,然后通过EJB访问数据层(Java对象一般用于在内联网上提供数据，处理服务)。
	- 在中间层服务器上包含.NET客户代码。.Net框架是Microsoft应对EJB框架(和J2EE 的其他部分)竞争的产品。本书使用的是Java例子，所以不介绍.Net。
* 图9-2显示了根据前面讨论的技术如何根据它们在三层系统中的正常位置组合在一起。 

== 9.6 其他技术 ==
* 身份验证：用户通过网络访问系统时，最好验证一下该用户的身份。为此，可以开发自己的机制，也可以使用己有的技术，例如，服务小程序就可以构建一个Web浏览器，在继续之前先显示登录屏幕。但是，我们需要的是一种迫使用户登录并在整个系统(从Web浏览器到中间层服务，再到后端)中保持其身份的机制。这个理想目标称为单签署 (如果要跨越其他域，就称为全球签署(global sign-on))。Java的单签署(single sign-on) 是J2EE的一部分。对于全球签署，新兴的技术包括Microsoft .Net Passport (www. microsoft.com)和 Liberty Alliance 开发的技术(www.projectliberty.org)。
* XML：在联网系统中，常常霈要把业务数据从一台机器传送给另一台机器。可扩展的标记语言(extensible Markup Language, XML)是一种文本语言，它把数据描述为结构化的名称-值对。XML文档是简单的字符串，所以可以通过为系统选择的任意协议来传输，例如HTTP或RMI。在XML文档中，可以开发任意结构和名称--值对.对于XML来说，当一个文档到达另一台机器时，目标机器必须能识别出数据的含义，而不仅仅识别出其结构。例如，如果用值NETAMOUNT定义了 XML文档，除非接收者知道该文档是一张发栗,NETAM0UNT是税前额，否則该文档就没有什么用。 所以,为常见的业务信息定义XML文档类型时要遵循标准。即使没有标准的文档定义， XML仍是有用的，因为它允许使用相同的库来分析、生成所有的文档(例如库可用于 Java)。XML可以用于存储制品，传输这些信息，例如，可以以XML格式存储电子表格文档。
* 事件和消息：事件是把信息广播给感兴趣的团体的一种常见机制。事件的问题是它们在网络上不能很好地发挥作用，因为很难使事件是线程安全的，其效率也很低(从服务器的观点来看)。通过网络广播的种较好方法是使用机器对机器的消息传输(machine -to-machine messaging)。消息是可以给感兴趣的客户广播的信息块：一旦服务器启动了广檑.就不再参与信息的传输，没有给特定的客户传输信息并没有什么不利影响(消息也可以用保证传输到的模式来发送)。
* SOAP：简单对象访问协议(SOAP)类似于RMI和CORBA。其区别是，SOAP 是基于XML的协议，因此将来有可能成为事实上的标准。
* Web服务：Web服务的理念是顾客(在家中或在公司里班胖服务器上存储和处理信息，并可以通过互联网或外联网访问，Web服务是要付费的。Web服务的一个简单例子是基于-浏览器的电子邮件，较复杂的例子是数字照片的处理、管理和打印。Web服务使 用TCP/IP和与XML相关的技术，如SOAP,部署为基于互联网的三层系统.

== 9.7 一般前端配置 ==
* 把所有复杂的业务逻辑放在中间层, 就可以根据个人喜好或可用的时间选择任意一种或所有前端配置.

=== 9.7.1 HTML/CGI和脚本 ===
* 利用CGI,在浏览器中显示的HTML包含一个或多个窗体, 从窗体中提取出名称一值对，把它们以CGI脚本的名义传送给Web服务器，该脚本应处理数据。可以由Web浏览器打包为一个URI: http: //www.blueskyuniversity.com/cgi-bin/buy.pl?b=Genuna&q=2
* Web服务器找到要运行的脚本(在这里是名为buy.pl 的PERL脚本),启动它，然后给它传送名称一值对，作为环境变量(可以由过程检索的搡作系统值)。而后服务器标准输出的所有内容就传送给客户浏览器，作为交互的结果。
* HTML/CGI配置如图9-3所示. Web服务器提供了对HTML文件, 脚本和其他媒体文件的访问.
* CGI有许多缺点:
	- 交互性差
	- 速度慢
	- 客户端没有数据验证
	- 服务器过载
	- 脚本不能移植
	- 不安全

=== 9.7.2 HTML/CGI和服务器小程序 ===
* 与上面的区别为在URL上, 不是要指定运行的脚本, 而是指定要实例化的服务小程序(Java对象): http://www.blueskyuniversity.com/servlet/BuyServlet?b=GemmaSq=2
* URL中有servlet部分, 小程序的类名BuyServlet. 该小程序处理请求.
* 为了把请求传送给服务小程序，Web服务器使用几个标准消息之一，最常用的是doPost(:HttpServletRequest,:HttpServletResponse); 名称一值对在 HttpServletRequest 的内部。当 doPost 完成其后端处理后，响应就放在HttpServletResponse中。Web服务器提取HttpServletResponse的内容，以正常方式把它送回Web浏览器。
* 比脚本优越的地方:
	- 性能
	- 可伸缩性
	- 可移植性
	- 易于使用

=== 9.7.3 RMI ===
* RMI是标准Java库的一部分, 只要安装了J2SE或J2EE, 就可以使用RMI. 其使用远程对象和使用本地对象一样简单, 只是有以下区别:
	- 服务器对象必须部署在要通过RMI联系的机器上; 它们可以提供远程客户机所需要的所有服务, 或是其他对象的生产车间.
	- 驻留服务器对象的机器必须运行一个命名服务，这个服务器过程运行在一个著名的端口上，允许远程机器根据名称査找服务器对象。RMI有自己的命名服务，称为注册表(registry),但最好使用可插入的Java命名和目录接口(JavaNaming and Directory Interface, JNDI),以利用命名服务提供的所有功能。
	- 通过网络传送的所有消息都可能抛出一个异常RemoteException,它确保客户程序员不会忘记他们是在本地Java过程的外部工作。
* 除了这些微小的限制之外，开发人员还可以使用RMI建立客户机一服务器或分布式体系结构。
* RMI配置上的每个主机都可以实现为小程序或应用程序。实现小程序的优点是，只要在网络的某个地方部署了 Web服务器，客户就不需要事先安装系统软件---所有的客户软件都可以在需要时通过Web浏览器和Web服务器加载。而对于应用程序，必须完成下面所列的一项工作：
	- 把客户软件部署到每个客户机上。只要更新了客户软件，就需要在所有的客户机上重新部署。这个选项不适合客户机上的系统软件比较大的情况(大软件就意味着依赖所使用的网络的速度)。
	- 部署Web服务器，再使用小引导软件加栽客户代码。引导软件仍滿要安装在每个客户机上，但至少可以保证，客户机在每次启动时，都会得到软件的最新版本。
	- 使用Java WebStart在需要时加载客户软件。Java WebStart是Sun提供的一个工具，支持Java应用程序的动态加载(一般是为小程序保留的机制)。要使用Java WebStart,需要部署Web服务器，再确保每个客户机h都安装了 Web浏览器、Java WebStart和Java PlugIn(J2SE的一部分)。如果要把客户机运行为应用程序而不是小程序，这是最简单的选项。
* 图9-5显示了 RMI小程序客户机的前端配罝。在中间层上，必须运行某种服务器过程，该过程包含与系统相关的代码和作为命名服务的一部分运行的通用代码。

=== 9.7.4 CORBA ===
* 公用对象请求代理程序体系结构(Common Object Request Broker Architecture. CORBA) .  CORBA类似于RMI,但它比RMI早
* CORBA 和RM1的主要区别是：
	- CORBA是多语言的：主软件可以用C++、Eiffel、C#、Java、甚至非面向对象语言如 C或COBOL编写(服务器软件对客户机来说仍是面向对象的)。
	- CORBA有自己的命名服务(但它也可以通过JNDI来使用)》
	- Java主机从CORBA上接收未检査的异常，从开发人员的代码中接收己检查的异常----这可能会产生混乱(已检査的异常必须由程序员处理，而未检査的异常不需要)。
	- CORBA比较费钱(用Java实现的免费版本适合于开发和测试)。
	- RMI可以访问整个Java2平台(至少是标准版本这有益于获得媒体文件的访问权限。
* 非Java程序员应把CORBA看做通过网络传送消息的最佳选择(它优于专用的、不能移植的产品Sun开发了-个搭桥协议RMI-over-II0P,它允许RM1主机与 CORBA主机混合在一起，但有几个限制。
* 图9-6显示了小程序访问CORBA的前端配罝。对于非Java主机，CORBA客户软件必须部署在每个客户机上(还要给每个新版本重新部署)。用Java编写的CORBA主机有与RMI主 机相同的部署选项。

=== 9.7.5 EJB ===
* Enterprise Java Beans(EJB)是J2EE的一部分, 是分布式Java系统的框架, 完全支持事务管理, 安全性和持续性.
* EJB的三个主要变体:
	- 实体Bean: 对应于 Jacobson/UML中的实体对象, 它是包含业务员信息和业务行为的业务对象. 实体bean可以由EJB实现代码使用用户选择的关系数据库自动存储, 也可以使用专用代码存储实体bean. 访问实体bean需要事务处理: 开发人员可以选择默认设置, 或者在一组选项中选择(表示不同速度/准确性的折中).
	- 会话Bean: 它以EJB客户机的身份管理业务工作. 客户机通过网络把消息发送给会话bean, 会话bean使用实体bean和其他会话bean来满足请求. 会话bean为它访问的所有实体bean和会话bean提供默认的事务处理. 另外客户可以控制事务处理在何时开始和结束.
	- 消息驱动的bean, 它与业界强大的机器对机器的消息传输实现方式无缝地集成在一起. 在完全的事务处理控制之下, 消息可以点对点地发送, 或者一次发送到几台机器上.
* 图9-7演示了EJB应用程序前端的配置. 为了让EJB工作, EJB必须降级为Enterprise Java Server(EJS).

== 9.8 后端配置 ==
* 到达中间层后, 其解决方案是在中间层上安装DBMS客户程序，从我们选择部署的服务器软件(脚本、服务小程序、RMI服务器、CORBA服务器或Enterprise Java Server)上访问它。访问数据库客户程序可以在中间层代码所在的过程中进行，也可以在其他过程中进行。另外，可以把服务器软件用作.Net客户程序或EJB客户程序。从中间层上访问的Enterprise Java Server或.Net服务器提供了业务服务，所以在逻辑上它应属于中间层。但是，所有这些技术都允许在多台机器上，以许多不同的方式部署，因此，服务器驻留在什么地方并不重要。

== 9.9 Java电子商务配置 ==
* HTML/CGI 前端作为默认机制.
* 如何把CGI、JSP、服务小程序、EJB和DBMS合并为一个一致、可伸缩的整体？基本理念是使用CGI访问提供了处务服务的服务小程序，服务小程序依赖可重用的EJB完成大部分工作：EJB依赖DBMS存储企业数据：最后，服务小程序把结果数据传送给JSP,以建立个性化的Web页面，并发送回客户机。完整的过程如图9-8所示(非标准的、UML样式的关键字用于部署每个对象如何在EJB框架中发挥作用)。
* 图9-8.
----
	案例分析<br />
	iCoot配置<br />
	由于HTML/CGI和服务小程序配置非常简单、移植性强、负栽小，所以可用于iCoot的第一次递增.以后的递增也提供一个适由的 Java客户，以便顾客可以通过RMI使用GUI快速而优雅地访问系统.在服务器端，使用一冬专用的业务服务器，它使用JDBC访问关系数据库.该业务服务器使用EJB会话bean提供对Java事务的访问，但不使用EJB实体bean,因为开发人员还没有对它们的用法进行过培训.<br />
		在前面的拓扑部署图(8.4.9节)中可以增加这些体系结构决策.图9-9把过程显示为子节点，每个子节点都用UML关键字<<ExecutionEnvironmen>>标记，通信路径现在显示为可导航-----路径名称可以用于表示通信协议.<br />
----
* 这个扩展图的部署调查如下：
	- iCoot数据层有两个数据库服务器(称为DBServer).有这样两个节点可以提高通过量和可靠性。每个DBServer都拥有一个DBMS过程，以管理对数据的访问.
	- 中间层与數据层通信，它包含两个服务器(CootServeO,也是为了提高通过量和可靠性。每 个CootServer都拥有一个CootBusinessServer(用于处理北务请求)和一个Webserver(用于处理静态HTML内容，把业务请求传送给CootBusinessServer). CootBusinessServer的數据访问由DBMS提供.因为它们都专用于所选的产品，所以不指定Webserver与CootBusinessServer之间的通信协议和CootBusinessServer与DBMS之间的通信协议。
	- 每个CootServer都可以由任意多个CootHTMLClient节点同时访问。每个CootHTMLCIient 都拥有一个WebBrowser,以使用HTTP访问某个Webserver节点。
	- 最后，还可以提供从CootGUIClient节点的访问?每个CootGUlClient都使用JRMP访问一个CootServer节点。因为未来递增版本的一个主题是机制允许这种请求进入 CootBusinessServer.所以不给出细节。也不给出CootGUIClient过程的任何细节.

== 9.10 UML包 ==
* UML概念“包(package)”可以组合相关的类。图9-10所示的包图(package diagram)把每个包显示为一个左上角有一个标签的方框。包名显示为黑体，位于方框的中间，如果要显示包的内容，包名就显示在标签中。包的内容可以是类或其他包。图9-10也显示了一个包到另一个 包之间的依赖关系(虚线开放箭头),它表示，源包使用目标包中的一些内容。 
* 包可以用于表示：
	- 层
	- 子系统
	- 可重用的库 
	- 框架
	- 应一起部署的类
	- ...
* 从编程的角度来看，包方便地映射已有的语言结构，例如Java包和C++命名空间，但包只是一个编译期间的概念，有助于组织代码，便于开发、部署和维护。
----
	案例分析<br />
	iCoot 包<br />
	图9-11显示了 iCoot的设计.在这个设计中，系统中的每一层都映射为不同的包.没有显示标准Java库(例如java.sql)中包之间的依箱关系，该依赖关系由business包用于访问数据库。如果包含所有的依赖关系，该图就会非常大.非常杂乱.<br />
----
* iCoot的主包是com::nowhere，它是“包nowhere嵌套在包com中”的简称。UML从C++ 中借用这个表示法表示命名空间操作符(在编写Java源代码时，"::"替代了 “.”）。尽管在iCoot中使用了事件，但control包和上述的包没有依赖关系。这是因为事件监听器和事件类型位于 control包中。protocol包包含轻型复制对象的定义，这些复制对象由服务器层导出，用于简化 对BusinessLayer的网络访问。
* 许多开发人员都使用包图来显示层。但是，这种方法有几个问题。
	- 第一，层是在决定如何把源代码组织到包中(组织形式也可能不同)之前选择的。
	- 第二，包图不允许显示一些重要的信息，例如iCoot中存在HTTPCGILayer是很重要的，但它不映射为可能实现的包，或映射为从库中借用的包(它只表示HTTP协议要与CGI一起使用)。因此，对于iCoot来说，使用特殊目的的层图比较合适，并有一个附带文档，来描述层的交互策略(参见图8-14)。
* 包图也不适合于显示水平分解的部分(子系统)：此时应使用部署图。图9-12显示了系统设计完成后的iCoot部署图，根据UML制品和包详细列出了 CootServer过程的内容。
* 图9-12的诠释:
	- 在UML中，制品是可以部署的内容，通常是一个文件。（文件可以是几乎所有的东西，例如程序、DLL、文件夹、XML数据或README文档)。制品由一张纸图标或<<artifact>>关键字来表示。图9-12中的制品是iCoot,静态HTML页面的文件夹，icoot.ear,服务小程序的压缩文档，JSP和EJB(Java命名约定.ear是enterprise archive的缩写)和cootschema.ddl(创建数据库的专用脚本)。
	- 添加从制品到元素组的依赖关系，标记为<<manifest>>(制品是元素的表达方式)，就可以显示模型中的哪些元素会引出某个制品。这里，icoot.ear显示为四个com::nowhere包的表达方式。也可以在部署图中显示其他依赖关系。例如，使用关键字<<use>>，就可以说明iCoot使用 icoot.ear。
----
案例分析<br />
更新的iCoot部署调查<br />
iCoot数据层有两个数据库服务器(称为DBServer)。有这样两个节点可以提高通过量和可靠性。每个DBServer都拥有一个DBMS过程，以管理对数据的访问。<br />
cootschema.ddl制品包含了创建数据库表的命令，其格式为该数据库所特有。这会使用与数据库相关的工具(这里没有给出细节)，部署到每个DBMS过程中。注意cootschema.ddl包含整个Coot系统的模式，因为iCoot和Coot使用相同的数据。<br />
中间层与数据层通信，它包含两个服务器(CootServer)，也是为了提高通过量和可靠性。每个CootServer都拥有一个CootBusinessServer(用于处理业务请求)和一个Webserver?(用于处理静态HTML内容，把业务请求传送给CootBusinessServer)。CootBusinessServer的数据访问由DBMS提供。它们都专用于所选的产品，所以不指定Webserver与CootBusinessServer之间的通信协议和CootBusinessServer与DBMS之间的通信协议。<br />
在每个CootServer中，iCoot文件夹包含静态的HTML页面，部署到Webserver上，而icoot.ear文档部署到CootBusinessServer上。icoot.ear文档包含com::nowhere包中的服务小程序、JSP、业务对象和(最终)RMI修饰工具。<br />
每个CootServer都可以由任意多个CootHTMLClient节点同时访问。每个CootHTMLClient都拥有一个WebBrowser,以使用HTTP访问某个Webserver节点。不需要把制品部署到CootHTMLClient 节点上。<br />
最后，还可以提供从CootGUIClient节点的访问。每个CootGUIClient都使用JRMP访问一个CootServer节点。因为未来递增版本的一个主题是机制允许这种请求进入CootBusinessServer,所以不给出细节。也不给出CootGUIClient过程的任何细节。没有指定部署到CootGUIClient节点上的制品。<br />
----

= 第10章 设计子系统 =
== 10.1 引言 ==
* 首先考虑如何设计业务层. 这通常包括确定该层有哪些对象, 它们如何连接, 它们的界面如何. 必须把分析阶段开发的, 面对业务的类模型转换为适合于所选的编程语言, 面向对象的类.
* 子系统设计需要把概念性的分析模型转换为可实现的类, 之后在系统设计模型中指定策略. 子系统设计可按照如下步骤进行:
	# 把分析类模型作为指导，设计业务层的类和字段。业务层包含问题域屮的实体和它们需要的各种支持类。
	# 确定持久数据如何存储，设计存储布局。持久数据是直到系统关闭才消失的数据。
	# 引用分析阶段生成的草案，最终确定用户界面的外观和操作方式。
	# 参考用户界面设计，遍历系统用例，注意中间层必须支持的业务服务。业务服务是客户机内发送给服务器的问题和命令，例如“购买一本书”或“预约汽车型号”。
	# 把业务服务传送给服务器对象，其消息可通过网络获得。服务器对象使用业务层，以各种客户机认可的方式实现业务服务。
	# 最终确定必要的措施，以确保并发控制和线程安全。并发控制就是使用业务规则控制对系统的访问：用户名和密码，在买票前预约等。线程安全即确保过程中的数据不被破坏，平行活动不互相干扰。
== 10.2 把分析的类模型映射为设计的类模型 ==
* 从分析转为设计时, 一些类会舍弃掉(例如控制器), 引入其他类(例如实现多重性的集合类). 
* 对于前面提及的每个设计类, 都需要选择其字段的名称和类型. 通常, 字段派生自分析阶段圈定的属性或关联. 不可能仅通过源代码就判断出某个字段最初是一个属性, 复合, 聚合还是关联. 这是需求捕捉和分析阶段生成的高级制品非常重要的一个原因.
* 除了属性和关联之外, 还需要考虑继承.

=== 10.2.1 映射操作 ===
* 在模拟系统用例时, 操作是验证分析类实现代码的一种副产品. 为了便于设计, 应忽略这些分析操作.
* 进入设计阶段, 使用编程术语"消息"和"方法", 来代替UML术语"操作".
* 添加消息的原因:
	- 允许客户机对象读取或修改字段值。
	- 允许客户机对象访问派生的数据(例如消息除了可以读取圆的半径之外，还可以读取直径)
	- 经验和直觉告诉我们某个消息是有用的。
	- 要使用的某个框架或模式需要某些消息。
* 另外，在为中间层设计业务服务时，也会为服务器对象设计消息。在使用业务对象判断业务服务是否令人满意时，也可能产生更多的消息。简言之，在把分析的类、属性和关系元素映射为对应的设计类、属性和关系时，就会产生许多消息。

=== 10.2.2 变量类型 ===
* 在引入一个字段时, 需要确定其类型是原型还是类. 在大多数情况下, 可以把字段的类型限制为:
	- 在毎个面向对象的编程语言中都有的原型类型和简单类(例如int、float、boolean、String、 List、Set和数组或[])。
	- 自己设计的类 
	- 选择使用的模式和框架中的类

=== 10.2.3 字段的可见性 ===
* 字段的可见性:
	- Private(在UML中表示为-):仅在定义类中可见。
	- Package(在UML中表示为~):仅在定义类和该包的所有类中可见。
	- Protected(在UML中表示为#):仅在定义类、该包的所有类以及定义类的所有派生类(在包中或包外)中可见。
	- Public(在UML中表示为+>:在所有的地方都可见。
* 消息的可见性:
	- 如果消息是包的接口的一部分，消息就是public。
	- 如果消息是类本身和包中其他类使用的实现代码，消息就是package。
	- 如果消息是类本身、其子类和包中其他类使用的实现代码，消息就是protected。
	- 如果消息是类本身使用的实现代码(降低了耩合性，允许编译器进行更多的优化，这与字段相同)，消息就是private。

=== 10.2.4 访问器 ===
* 最好为字段提供访问器(accessor)消息。访问器消息有两个变体：读取器(getter)返回字段的值，设置器(setter)给字段设置新值,访问器允许集中访问字段，这更便于维护?访问器也便于编译器进行优化(尤其是关联的变量为private的情形)?在类中，可以略微放松规则：通常可以直接读取字段，但使用设置器来设置字段。 

=== 10.2.5 映射类, 属性和复合 ===
* 类字段的表示法与实例字段一样，但类字段不加下划线。同样，类消息使用的表示法也与实例消息相同，但类消息要加上下划线。这种下划线策略与类名(在类图上)和对象标签(在对象图上)的下划线策略不同一类名不加下划线，而对象标签加下划线。是的，这很容易混淆。其理由是给不常绘制的版本加下划线。
* 图10-1显示了把iCoot分析类图的一部分转换为设计类图。在映射到设计图时，解决了三个主要问题：要实现的类、属性的类型和如何映射复合。
	- 在这个例子中，保留了两个分析类，而且不需要引入新的支持类(除了 String类之外)。
	- 所有的属性都转换为某种适当类型的私有字段。可选的属性以相同的方式映射，惟一的区别是，在运行期间，对应的字段应使用null值。
	- 复合关系要多加考虑。为了便于分析，复合是双向的;从容易找出的任一个对象开始到另一端的对象。但在设计时，必须考虑到，字段只能指向一个方向(在运行期间，可以从固有对象指向远端的对象，但不能反向)。所以，需要确定是在关系的每一端都有一个字段，还是只在一端有一个字段(还要判断在哪一端有这个字段)。
* 复合的初始关系是从复合者到被复合者。这反映了复合者是关系的拥有者，而且复合类似于属性：正常情况下,固有对象使用属性或被复合对象的服务.但反过来不行。注意这不是绝对的, 如果觉得更适合自己的系统，就可以把字段放在被复合的对象中，或者放在复合和被复合的对象中(UML还有数据类型的表示法，专门用于内嵌的属性)。
* 一旦决定了复合的方向，就可以给类图添加箭头来表示它，再添加角色和可见性来表示复合如何映射为字段(参见图10-1)。在运行期间，消息只能沿着箭头的方向传递.还可以删除复合，在CarModel中显示"details:CarModelDetails字段。大多数UML创建工具都允许开发人员随意扩展和压缩这类信息。
* 一旦决定了复合的方向，就可以给类图添加箭头来表示它，再添加角色和可见性来表示复合如何映射为字段(参见图10-1)。在运行期间，消息只能沿着箭头的方向传递.还可以删除复合，在CarModel中显示"details:CarModelDetails字段。大多数UML创建工具都允许开发人员随意扩展和压缩这类信息。
* 在图10-1中，advert和poster字段都是String类型，这是因为不需要在iCoot系统中处理和存储原始媒介。而可以在Web服务器的控制下，把这些复杂的类型部署为文件，例如*.ram和*.png文件，再把相关的URI存储为厲件值。例如，CarModel可以把“/adverts/mcgs.ram” 作为其advert字段的值。

=== 10.2.6 映射其他关系的关联 ===
* 三种关联: (一般)关联, 聚合(强)和复合(更强). 这里不区分聚合和关联.
* 从分析阶段继承下来的大多数关联, 以及专门为设计阶段添加的新关联, 最终映射为对象上的字段. 一些关联映射为类字段. 无论映射为什么字段, 由于字段只能在一个方向上导航, 所以需要决定是要双向导航, 还是要单向导航. 这样, 关联的实现可取决于每一端的多重性, 一对一, 一对多, 还是多对多.

==== 1. 一对一关联 ====
* 如果使用双向关联, 就需要添加代码, 确保关联的步调一致.
* 可选关联(一端的多重性为0..1, 或两端的多重性都为0..1), 类似于一对一关联, 但字段可以取null值(表示远端没有对象).

==== 2 一对多关联 ====
* 图10-3显示了一个一对多关联的例子. 在一对多关联中, 仍必须确定是在一端还是两端放置字段, 这也适合于一对一的情形. 
* 如果一端放置字段, 就必须准备存储多个关联对象. 可以用某个集合类来存储对象, 如List, Set, Bag
* 图10-3中关于带集合值的字段的表示法，不是合法的UML。肯定可以把字段显示为可导航的关联，并用一个角色来表示可见性和字段名，但:List部分是不标准的。

==== 3. 多对多关联 ====
* 图10-4, 有一个Make, 可以制造出任意数量的CarModel对象, 每个CarModel都可以由一个或多个Make对象制造出来. 这里允许按照重要性对Make对象排序.
* 图中选项C, 其同步问题比一对一和一对多的情形更严重; 必须搜索整个集合, 找出对象, 而不能直接访问各个对象. 这种情况下, 引入一个关联类(association class)来处理复杂性比较好. 如下所述.

==== 4 关联类 ====
* 如果数据与某个关联有关, 就需要关联类. 图10-5上部的分析类图就是关联类的一个例子.
* 在图10-5中可以看出，Customer对象可以预约任意数量的CarModel对象，CarModel对象可以由任意数量的Customer对象预约，但对于每个Reservation链接，都需要记录预约号、时间戮和状态，这些数据不属于Customer,也不属于CarModel,它属于关联本身。因此，应把Reservation引入为一个关联类，并带有适当的属性。
* 在设计关联类时，最容易的是创建一个设计类，给所有的属性设置字段，再另外设置两个字段，指向被关联的对象.如图10-5下部所示。接着，为每个链接创建该关联类的实例。(即每个预约关联)
* 如果要从CarModel导航到它的Reservation对象，就必须给CarModel添加一个字段，并带有所有的同步问题(类似的过程也适用于Customer)。另外，还可以在ReservationHome类上提供一个findAllReservationsFor(:CarModel)消息。（home允许创建和查找特定类的对象，通常是在底层的数据库中査找，每个home对象都是单一的(singleton)模式,我们要编写代码，确保只存在home的惟一实例)。
* 关联类是把分析阶段的任意关联映射到设计阶段的最般方式。因此，如果需要，可以引入关联类来表示分析类图屮的每个关联。这会缓解前面提到的同步问題。一些代码生成工具就是以这种方式操作的，但如果手工编写代码，就会觉得这太麻烦了。
----
案例分析<br />
iCoot业务层类图<br />
在图10-6中，iCootBusinessLayer的所有分析类都映射为设计类，可以直接在任意流行的面向对象语言中实现.这个类图封装在一个UML框架中，包名显示在左上角.这些类的字段详见8.5节.<br />
----

=== 10.2.7 通用标识符 ===
* 大多数业务对象在其生存期的某个时刻，都需要按键(key)来检索。键是属性值或值的组合，对每个实例来说，键都是惟一的。例如，银行账户由其账户号码和有序码构成，进行惟一地表示)
* 在软件系统中，处理不同类型的键是很麻烦的。因此，最好引入一个惟一的号码，从同一个类的对象中区分每个业务对象。这有助于同步对象的副本，追踪它们在网络上的移动轨迹，高效统一地处理键(例如通过home对象)。对象和链接存储在数据库中时，也可以使用这种通用标识符——当系统关闭时，通用标识符可替代内存地址。
* 通用标识符的合适类型是整型。整数的特定类型取决于每个类能容纳的不同对象数：16位整数(Java中的short)允许有65000个不同的实例，32位的整数(Java屮的int)允许有40亿个不同的实例。如果40亿还不够，则可以使用64位的整数(Java中的long),其实例数不限(大约18百万的三次方>。
* 如果使用通用标识符，就应在对象的构造期间设置，之后它就是固定不变的。图10-7演示了 CarModel类的通用标识符的实现。UML<<create>>关键字用于表示CarModel操作创建 CarModel的实例。在UML中，这是一个很好的方式, 因为没有关键字，读者就必须假定与类同名的操作是“构造函数”，但实际上构造函数是否存在，它们的名称是否遵循相同的规则， 取决于语言本身。因此，本书把术语“构造函数”用作“用于创建类实例的操作”的缩写方式，但在图中仍使用<<create>>关键字。
* 一般, 构造函数不是公共的, 这就允许开发人员控制给哪些通用标识符复制, 例如使用home(如果构造函数是公共的, 任意客户机就可以使用别处的标识符来创建CarModel了).
* 图10-7中, 构造函数有包访问权, 所以对象可以由驻留在同一个包中的CarModelHome类来来创建.

== 10.3 使用关系数据库实现存储 ==
=== 10.3.1 数据库管理系统 ===
* 数据库管理系统(Database Management system, DBMS)管理多个数据库中任意数量的数据, 数据库就是把数据隔开的区域. 这里DBMS用于:
	# 使用数据定义语言(Data	Definition Language, DDL)创建一个模式，来描述要存储的数据。
	# 使用数据操纵语言(Data	Manipulation Language, DML)添加、删除和更新数据库中的数据。
	# 使用数据査询语言(DataQueiy	Language, DQL)从数据库中检索数据。
* 理想情况下，DDL、DML和DQL都应是声明性的语言。在声明性的语言中，指定了内容，而不是步骤。例如，我们不知道也不想知道DBMS如何在磁盘上物理组织数据，而只是说明 存储什么类型的数据，数据值是什么，要检索什么数据。

=== 10.3.2 关系模型 ===
* 关系模型是一种数学模型，它很整洁、可靠，易于优化(对DBMS来说)。但是，关系模型像一个有索引卡的文件柜，而不像一个复杂、连接紧密的对象库。所以，语义上的分歧很大。
* 面向对象式的模型很容易映射为关系模式，但很难预测几个映射屮哪一个最适合于某种软件系统(考虑存储效率和访问速度)。所以，需要使用某种映射工具或持久层来试验，找出最适合系统的映射。
* 下面介绍一种映射：直接的、纯粹的映射。这样就可以确保它能在关系数据库中存储面向对象的数据。对于这种映射，假定控制了数据的存储方式。实际上，我们不可能这么幸运：模式在数据库管理员(Database Administrator, DBA)的控制之下，或者数据库已经存在，是一种不能修改的老系统——在这些情况下,就必须对映射进行“逆向工程”。
* 底层技术包括使用SQL语句(通过像JDBC这样的库)把数据库中的数据读到运行时对象中，再编写新数据，返回数据库。
* 数据库由业务层封装, 我们不必为客户机程序员和数据库层调整业务层和数据库层----映射代码可以完成其他工作.

==== 1. 表 ====
* 数据表, 包含列和行. 图10-8为ADDRESS表, 四列字符串数据(HOUSE, STREET, COUNTRY, POSTCODE)和一个整型ID.
* 本书适用的类型:
	- VARCHAR(X): 字符串, 最多X个字符.
	- INTEGER
	- DATE
	- TIMESTAMP: 日期和时间的组合.
	- BOOLEAN.
* 关系模型中, 每一行必须是唯一的. 对于ADDRESS表, 通过唯一的ID属性实现.

==== 2. 键 ====
* 键是一个值或值的组合, 它惟一地标识了一行. 
* 一些表有多个候选键. 需要选择一个候选键作为主键.
* 主键显示为黑体, 如果手工绘制, 则在列名的旁边加上"+".

==== 3. 把对象模型映射为关系模型 ====
* 分析图更接近于关系模型, 因为它没有显示关联的方向. 但设计类图把类型赋予字段, 在设计表时需要知道字段的类型. 所以, 应使用分析模型来设计表, 再根据设计图确定类型.

=== 10.3.3 映射实体类 ===
* 引入一个与实体类同名的表.
* 每个简单的字段(原型或字符串), 都可以在表中添加一个与字段同名的列和一个对应的SQL数据类型.
* 使用一个整数属性(如ID)作为主键很重要.

=== 10.3.4 映射关联 ===
* 关系数据库直接存储双向关联.
* 数据库模式更类似于分析类模型, 而不是设计类模型(应在生成数据库模式之前设计业务层, 因为设计过程比分析模型难, 有助于选择属性类型).

==== 1. 一对一关联 ====
* 一对一关联, 可以给一个实体表添加外键, 外键为一个表中指向另一个表中主键的一项. 即一个表的一行对另一个表的一行的引用. 外键的列其列名显示为斜体(手工则在列名前加上">").
* 图10-9中, CARMODEL表包含一个外键CARMODELDETAILSID. CARMODELDETAILS表添加外键CARMODELID. 由于关系数据库的双向性质, 不需要在两个表中都添加外键.(这里显示的类图使用了分析表示法, 没有可导航性, 但每个表都添加了通用标识符, 只是它们都不是分析层次的属性).
* 外键的另一种替代方法为把两个表合并为一个表. 为了便于维护, 只有一个表不能独立表示一个实体时, 才应合并表. 例如，如果CarModelDetails只是CarModel的属性组合，为了方便程序员编程，应给CARMODEL表添加RELEASEDATE、CATALOGDATE、CLIP和POSTER列，删除CARMODELDETAILS表。这样，开发人员就可以把CarModelDetails看做 一个实体，因为它有一个通用标识符。
* 对于可选关联(多重性是1和0..1), 可一个给可选的一端添加外键. 关系数据库偶尔也支持可空的(nullable)列. 可空列允许单元格包含NULL值. 

==== 2. 一对多关联 ====
* 对于一对多关联, 可以在"多"表中添加外键, 如图10-10所示.

==== 3. 多对多关联 ====
* 对于多对多关联, 一个外键不足以标识关联两端的多个实体. 例如图10-11中的Make和CarModel. 纯关系中, 表中的每个值必须是原子化的, 即不是值的集合. 所以不能把CarModel的所有Make对象存储在CARMODEL表的MAKEID列中.
* 使用链表, 链表中的每一行都表示一个表中的实体与另一个表中的实体之间的连接. 如图10-11.
* 还可以使用链表存储一对一和一对多关联.

==== 4 关联类 ====
* 关联类由于有自己的数据, 无论关联两端的多重性如何, 都必须映射为链表. 与普通的链表不同, 表示关联类的链表有属性列---它们甚至有ID列(如果关联类本身表示一个实体).
* 图10-12显示的表表示关联类Reservation.

=== 10.3.5 映射对象状态 ===
* 对于关联了状态机的业务对象，例如状态机图中的对象，需要记录每个对象所处的状态。在业务层，业务对象可以有一个简单的字段表示其状态，可能是String或int,也可以有一个复杂的字段指向一个状态对象(用State模式描述)。
* 如果选择使用String或int,就需要确保字段只能有某些值。对于iCoot, Reservation有6 个状态，因此必须选择 6 个字符串(waiting、notifiable、collectable、needingRenewaU storable 和concluded)或6个整数(0~5>.从数据库的角度来看，也可以采用一种简单的方法：给 RESERVATION 表添加一列 STATE,把它的类型设置为 VARCHAR 或 INTEGER。(INTEGER 版本比较快，但较难调试>。这种方法如图10-13所示。
* 或者采用较复杂的方法：给每个状态引入一个新表，使用外键表示预约所处的状态。例如， 图10.14显示了 6个状态表中的两个，分别表示预约7处和99处于等待状态，预约1处于可取车状态。这个复杂的方法比较好。它是否比简单方法更高效取决f系统中的使用棋式，这是很难预测的。
* 在存储状态时，有时必须处理状态属性---在业务对象处于特定状态下时与该业务对象相关的数据。例如，当某个预约处于等待状态时，需要知道该预约上次的更新时间(因为在等待一个星期之后，该预约就需要更新了)。同样，对于可以取车的预约，需要知道汽车何时处于可取车状态(因为如果顾客没有在三天内取走车，汽车就变成可存储状态)。
* 在使用状态表的方法中，可以把状态属性存储为额外的列，在图10-15中演示了这种方法， 其中有两个示例状态。在使用状态列的方法中，必须在业务对象表中为每个状态属性添加一列， 业务状态表中可以有许多列。每个列都必须是可空的，这样当对象不处于相关的状态下时，就可以省略数据。在图10-16中演示了这种方法，其中有两个示例状态。最好避免使用可空列， 所以在这种情况下，使用状态表比较好。

==== 1. 映射继承 ====
* 为了把继承层次映射到表上,可以为每个类引入一个表，其屮的列对应于类添加的属性。这样，就可以找出对象的所有厲性，表必须共享相同的主键。例如.图10.17显示了映射为三个表的Customer类层次，这三个表是CUSTOMER表、NONMEMBER表和MEMBER表。 CUSTOMER表有三列，分别对应于Customer类定义的属性;NONMEMBER表有一列，对应 于NonMember类定义的属性;MEMBER表有两列，对应于Member类定义的属性。
* 与通常一样，通用标识符(己添加到Customer类中)用作主键，这次它显示为三个表的主键。 例如，在检索Customer 33的数据时，从CUSTOMER表中选择NAME、AMOUNTDUE和 PHONE；接着，测试在子类表中是否有键为33的一行(如果有，则Customer 33实际上是子类的一个实例)：在这个例子中，Customer 33有NONMEMBER数据，所以选择其License。最终结果是图10-18中的NonMember。
* 与对象状态的映射一样，也可以把所有的属性放在一个表中(这说明，作为类实例的对象类似于处于特定状态下的对象)》例如，在图10-19中，有一个CUSTOMER表，它的CLASS列指定每一行的类。另外，该表有一个可空列.用于表示层次结构中的每个属性。
* 与以前一样，选择映射为多个表还是一个表取决于个人喜好、经验、预测和试验。
----
案例分析<br />
iCoot数据库模式<br />
iCoot已完成的数据库模式如图10-20所示.每个表都显示为名称后跟列类型(列类型位于括号中).与以前一样，主健显示为黑体，外键显示为斜体(主-外键是粗斜体).为了完整起见， 这个模式包括了完整Coot系统的几个部分，例如NONMEMBER和DATELOST。<br />
----

== 10.4 最终确定用户界面 ==
* 开发的早期阶段, 即需求和分析阶段, 考虑用户界面的功能. 可获得如下内容:
	- 用户界面草图. 有助于在需求捕捉阶段生成系统用例.
	- 通信图中的边界对象. 动态分析阶段使用通信图显示用例的实现过程. 每个参与者通过边界对象与系统交互.
* 提取粗糙的边界对象, 粗糙的用户界面草图和准确的用例, 转换为可以直接实现的用户界面描述.
* 用户界面设计的一些基本原则(尤其适合于访问多层系统的瘦客户机).
	# 以用例为指导: 用例用于给用户界面建立结构. 尽可能使用例简单, 组合相关的用例. 避免把单个用例或一组相关用例分割为多个界面.
	# 简单
	# 使用选项卡
	# 使用向导: 一系列页面, 引导用户按照步骤完成复杂的活动.
	# 避免使用多个窗口

== 10.5 设计业务服务 ==
* 开始设计服务器层, 它包括许多服务器对象, 这些对象和业务层的对象协作, 为客户提供了一个简单的界面.
* 业务服务是中间层提供其客户使用的查询和命令. 例如iCoot, 可以派生出如下的业务服务:
	- 从目录屮读取索引标题
	- 从给定的索引标题中读取汽车型号 ?读取每个汽车型号的目录
	- 读取所有汽车型号的引擎规格
	- 读取汽车型号的所有广家
	- 读取给定目录、引擎规格和厂家的汽车型号 ?读取给定汽车型号的详细信息
	- 预约汽车型号
	- 读取给定会员的信息
	- 改变会员的密码
	- 读取给定会员租赁的汽车 ?读取给定会员的预约记录 ?取消预约
* 业务服务表示客户机上的用户界面和中间层上的业务逻辑之间的信息流小结。在遍历用例时，参考用户界面设计和系统体系结构，就可以生成业务服务。（把服务器的接口分解为它提供的服务，这种方法可以用于各种通信情形。例如，可以扩展本节讨论的内容，确定子系统中的层如何通信)。
* 为了使业务服务在HTML/CGI界面上有意义，必须假定用户界面位于客户层和中间层之间：HTML窗体、服务小程序和JSP结果页面构成了一个用户界面，只是有些部分运行在中间层上。甚至可以在单独的中间层机器上执行服务小程序，该机器与进行业务处理的机器不是同一台机器，从而减少了业务对象上的负载---在这种情况下，运行服务小程序的机器是中间层的一个客户机，而不是中间层的一部分。所以，在下面的几小节中，术语“客户机”表示：
	- 一段代码，例如应用小程序，运行在与业务层不同的单独机器上。
	- 服务小程序，运行在单独的进程中，或运行在与业务层不同的单独机器上，
* 利用业务服务实现客户机-服务器通信，可以：
	- 简化客户机代码。因为大多数客户机接口都只需要系统的一部分功能，每个接口可以只有系统功能的删节版本。
	- 使业务层比较复杂。可以使业务层尽可能复杂、强大或可重用，即使业务层有变化，也不必担心对客户机的影响。
	- 建立即插即用的服务器层。最好能提供不同类型的接口，来处理不同的用户喜好或客户机功能——例如，应用小程序/RMI与HTML/CGI-服务小程序，而不必每次都重新实现中间层服务。

=== 10.5.1 使用代理和副本 ===
* 在客户机请求业务服务时，结果可能包含一个或多个业务对象。例如，如果客户机请求是“读取汽车型号的所有Make对象”,结果就是Make对象的一个列表。除了检索业务对象之外，客户机还可以给服务器发送业务对象。例如，如果客户机请求是“取消预约”，就不需要指定预约。
* 至少在逻辑上，业务对象在客户机和服务器之间来回流动。如果处理的是一层系统，就没 有问题：只需在运行时系统上传送对象指针，根据需要给对象发送消息即可。但是在处理网络 时，事情就不是这么简单了。
* 在RMI等技术的帮助下，可以使消息通过网络在对象之间传送：每个对象都位于一个运行时系统内部，但消息可以从外部到达该系统内部。或者，可以在网络上传送对象的副本;每个运行时系统都有一个它需要的对象副本，在本地给它们发送消息。在子系统的层之间通信时，有类似的问题;是在层之间传送对象引用，还是传送对象副本？（应使用一个开放的层，以越过其边界来传送引用，而使用封闭的层可以传送副本)。
* 为了更加精确，有两个基本的策略：代理(proxy)是一种客户机对象，它知道如何把接收到的消息传送给位于其他位置的业务对象。副本(copy)是包含业务对象数据的客户机对象。
* 使用代理的主要优点是：
	- 所有的客户机都会看到相同的对象，所以它们总是在处理相同的信息。
	- 所有的运行时系统都合并为一个统一体：分布式对象的处理方式与本地对象相同。
* 代理的主要缺点是：
	- 业务层对象必须确保其安全。例如，在从客户机上接收消息时，必须确保客户机有发送消息的权限。这会使业务层比较复杂(另一种安全模式较容易实现：业务层对象只能 由服务器层访问，服务器层必须保护其业务服务)。
	- 增加了网络通信量。在面向对象的系统中，一般要先找到对象，再给它发送消息；使用代理技术后，对象的内部检索很快，但给对象发送消息较慢(因为每个消息必须在网 络上传送)。
	-增加了中间层的负担。运行在中间层上的业务层一直在执行所有的方法。
* 使用副本的优点是：
	- 减少了网络通信量：要检索更多的信息(所有对象的数据>,但方法执行得很快(因为它们在本地运行)》
	- 处理并不都在中间层上进行，因为一些业务方法在客户机上执行。
	- 对业务方法的直接访问不必保护其安全，因为只有服务器层有直接访问权限，服务器层本身就是安全的。
	- 对象的实现不必是并发安全的：一旦以客户机的名义创建了一个副本，该客户机就对副本有独占访问权。
* 副本的主要缺点是：
	- 要复制的数据太多。例如，如果复制一个汽车型号，就可能需要复制所有的CarModelDetail 对象、所有的Make对象、所有的Reservation对象、进行了预约的所有Member对象等。
	- 副本的步调可能不一致，因为每个客户机都有对象的一个独立副本。
* 手工采用轻型副本(lightweight copy).

=== 10.5.2 给业务服务分类 ===
* 将业务服务组合为相关行为组(换言之, 就是对象上的消息). 这些服务器对象有几个自己的属性, 它们不应以客户机的名义记录状态(每个客户机都必须记忆它自己的状态). 服务器对象驻留在多层系统的服务器层上.
* 为iCoot设计的服务器对象如图10-25所示. 业务服务分类为预约, 身份验证, 会员信息, 目录信息和租赁.

=== 10.5.3 会话标识符 ===
* 为了防止黑客的攻击，常常需要限制客户机对权限服务的访问。例如，对于iCoot,就有受限服务，如“預约汽车型号”，它需要客户登录;还有无权限的服务，如“从目录中读取索引标題”，它可用于每个人，甚至是黑客。
* 一些客户机-服务器协议，如HTTP,有一个标准的挑战(challenge)机制，用于给用户显示登录屏幕：输入的用户名和密码要在服务器上进行验证，如果验证成功，就给客户机提供一个惟一的会话标识符。但是，如果要提供即插即用的业务服务，例如处理任意前端的服务，就必须自己实现一个机制。图10-25显示了实现它的一种方式。所有权限服务都把一个long名称作为其第一个参数:这一定是服务器层创建的会话标识符，否則权限服务就会失敗。为了获得会话标识符,客户机必须使用AuthenticationServer上的logon消息(steal参数由客户机用于指定是应终止这个会员的己有会话一这是单登录机制的一部分)。
* 在调用logon方法时，AuthenticationServer会使用业务层检查会员号和密码。如果客户的凭证是正确的，AuthenticationServer就生成一个随机号，并把它关联到业务层的对应Member 对象上。随后，只要调用了权限服务，相关的册务器对象就可以使用会话标识符査找Member 对象，并进行处理。自然，如果最初的凭证或会话标识符无效，客户机就会接收到错误消息。 会话标识符必须很难伪造——随机生成的64位号码就足够了。黑客一般不会猜测64位随机号码，因为他们成功的机会太渺茫了.
* 提供可移植的、有限制/无限制的机制的另一种方法是，把会话标识符设置为一个对象。 通过封装，在选择采用难以伪造的信息时会有更多的灵活性，

=== 10.5.4 业务服务的实现 ===
* 为实现业务服务, 遍历用例，绘制顺序图.，显示出需要发送的消息。这个过程称为业务服务的实现(business service realization).它类似于分析阶段中用例的实现：遍历用例，绘制通信图，描述出业务对象支持的实现方式。要描述业务服务的实现，应使用顒序图，而不是通信图，因为顒序图更紧凑(这里专指实现方式，所以有更多的信息显示出来)。
* 图10-26显示了 AuthenticationServer的logoff方法的顺序图。顶部是交互过程中涉及到的对象。与通信图和对象图中的对象不同，顺序图中的对象没有带下划线的标签。时间轴从上指向下，所以首先，顶部的Member参与者通过AuthenticationServlet启动注销， AuthenticationServlet 再把 logoff 消息发送给 A"uthenticationServer, AuthenticationServer 把 findByld消息发送给MemberHome,依此类推。
* 顺序图上垂直的虚线称为生命线(lifeline,在手工绘制的图中，这些线条不是虚线)。垂直的灰色矩形称为活动条(activation bar),它们表示对象何时执行方法(在手工绘制的图中，这些活动条可以是白色的，或者省略)。每个顺序图都可以放在一个方框(frame)中，这个方框在左上角有一个操作符，就像前面设计类图那样，区别是操作符不同(所有的UML图都可以放在一 个方框中，操作符表示图的内容)。在顺序图中，操作符是sd后跟顺序图名。在类图中，使用pkg操作符，表示包含类的包。在本书中，只有iCoot的顺序图和设计级类图才加方框。方框还可以用于包含循环和对其他顺序图的引用
顺序图上垂直的虚线称为生命线(lifeline,在手工绘制的图中，这些线条不是虚线)。垂直的灰色矩形称为活动条(activation bar),它们表示对象何时执行方法(在手工绘制的图中，这些活动条可以是白色的，或者省略)。每个顺序图都可以放在一个方框(frame)中，这个方框在左上角有一个操作符，就像前面设计类图那样，区别是操作符不同(所有的UML图都可以放在一 个方框中，操作符表示图的内容)。在顺序图中，操作符是sd后跟顺序图名。在类图中，使用pkg操作符，表示包含类的包。在本书中，只有iCoot的顺序图和设计级类图才加方框。方框还可以用于包含循环和对其他顺序图的引用
----
案例分析<br />
iCoot的顺序图<br />
iCoot小组的一个成员描述了如图10-26所示的交互过程，如下所示：<br />
当Member参与者选择注销时，其浏览器就会告诉AuthenticationServlet要注销.接着，AuthenticationServlet把注销消息以及它从浏览器会话中检索到的Member ID发送给 AuthenticationServer.<br />
AuthenticationServer 使用 ID 从 MemberHome 中检索对应的 Member,再给该 Member 发送 setSessionld消息，并把0作为参數，该消息传送到Member的IntemetAccount上。IntemetAccount 存储会话标识符0,表示Member已注销.<br />
最后，给Member参与者显示主页，以便他们访问顾客服务或再次登录。<br />
----
* 对于业务服务的实现，需要显示在服务器对象和业务层对象之间流动的消息，但不需要显示业务层对象的内部工作过程。根据系统的规模，在实现图上显示每个业务服务有时是可行的，有时不可行。一般应显示最重要的业务服务----用例有助于确定哪些业务服务是最重要的。在每个用例中，都有几个正常的业务服务和几个异常的业务服务。从这里的情况来看.显示最常见的业务服务的正常路径就足够了。
* 在绘制顺序图时，会发现业务层对象的接口上有越来越多的消息。业务层对象上产生的消 息，以及利用直觉、经验、库、模式、框架和推测产生的其他消息会发送到规范阶段。在规范 阶段，应尽力完成对象接口，描述霈要的行为

== 10.6 使用模式, 框架和库 ==
* 设计模式
* 框架, 框架两个区别: 第一, 它们比较大, 第二, 一些代码已经编写好.
* 流行框架 Enterprise JavaBeans.
* 库---预先编写好的类集.

== 10.7 事务 ==
* 事务也称为工作单元, 用于分隔一组数据库访问.
* 事务确保:
	- 数据库中的信息不会被系统问题破坏.
	- 客户不会获得过时的消息.
* 数据库客户机启动一个事务, 访问数据, 提交事务. 提交失败可以回滚.

=== 10.7.1 保守并发和开放并发 ===
* 保守并发: DBMS确保当一个事务处于激活状态时, 没有其他事务能进行有冲突的访问. 
* 开放并发中, 事务可以随意访问, 但在提交事务时, DBMS会检查是否有其他事务在执行有冲突的访问.

=== 10.7.2 使用事务和对象的一般规则 ===
* 冲突: 复杂的对象图, 想在一个长事务中解决整个块; 关系数据库默认有一个保守锁定机制, 对象数据散布在许多表中, 应使用短事务, 避免锁定数据库的大部分数据.
* 使用专业的框架, 如EJB. 如手工映射, 考虑以下建议:
	- 组织对象和访问路径, 以减少重叠.
	- 使用主键
	- 是事务尽可能短.

=== 10.7.3 上层中的事务 ===
* 事务有一个连锁反应：它们通常位于数据库层中，但会出现在持久层中。一旦它们出现在持久层中，通常就会出现在业务层中; 一旦它们出现在业务层中，服务器层的开发人员就必须理解它们，了解如何正确使用它们。
* 再退出客户机前, 事务一般不能隐藏. 为此, 服务器层必须把事务封装到简化的请求(业务服务)中.

== 10.8 处理多个活动 ==
=== 10.8.1 控制多个任务 ===
* 对于进程, 操作系统有调度算法和分配优先级.
* 管理外部资源的访问(如文件和数据库).打开文件时, 锁定文件防止其他进程编辑该文件.

=== 10.8.2 控制多个线程 ===
* 客户机上多线程的优点:
	- 用户可以同时运行许多应用程序, 在一个应用程序中做许多事情.
	- 即使应用程序忙碌, 用户也可以与用户界面交互.
	- 即使应用程序忙碌, 用户界面也可以更新.
* 从服务器的角度看, 采用多线程的优点是:
	- 它允许同时给许多客户提供服务, 且系统没有多个进程的开销. 
	- 它会减少服务器上的空闲时间
	- 它会减少超时现象.

=== 10.8.3 线程安全 ===
* 在面向对象的程序中, 保护数据的关键是确保每个数据都只能通过一个管理该数据的对象来访问. 使用互斥(mutual exclusion).
* 在多线程中能安全使用的代码成为线程安全或者MT安全.

==== 1. 不变性 ====
* 不变性是指数据不会改变的对象. 数据表示
	- 对象的字段值
	- 存储在外部资源中, 由对象管理的值(例如文件中的文本)
	- 对象中由该对象指向的值
	- ...
* 不可变对象的优点为它们是线程安全的
==== 2. 固定值 ====
* 死锁
* 获得线程安全的一个简单技巧是查找对象中的固定值. 例如Pi值.
* 确定了对象的哪些字段是固定的后，就可以把对象分戒两个部分：一是固定值，它们不需要特定的代码来保护，一是可变的值，它们痛要特定的代码来保护。固定值只需在创建了对象后是不可变的，换言之，可以在对象的构造函数屮搡纵固定值;只要在构造函数执行完后不改变其值即可.其原因是只有一个线程能进入构造函数;该线程请求运行时系统创建对象。在构建对象时，其他线程都不能进入该对象，因为此时对象还不存在(假定构造函数在执行过程中，没有使对象可用于其他线程)。

==== 3. Java中的同步 ====
* 把每个共享的资源封装到一个对象中, 就可以解决大多数多线程问题. 接着, 对象负责确保一次只允许一个线程进入. 编程应支持这个互斥限制.
----
案例分析<br />
iCoot中的线程安全<br />
如何确保iCoot的线程安全？可以分别考虑每个层(使用层的另一个优点)：<br />
?为了符合服务小程序的编程样式，服务小程序(分布式接口的一部分)是无状态的，所以是多线程安全的.会话数据(例如当前用户的PMember)存储在每个客户机的一个HttpSession<br />
中，使用Java的同步机制来保护(使用同步块).(作为标准HTML/CGI+服务小程序机制的一部分，Web服务器存储会话对象，Web浏览器存储会话标识符).<br />
?即插即用的服务器对象也是无状态的，因此是线程安全的：每个业务服务都返回一个响应(作为协议对象)，该响应可以从业务层中检测到，只由请求它的客户机使用.<br />
?通过仔细的编程，确保业务层是多线程安全的，使多个线程可以通过它在服务器层上运行，而不会破坏从数据库层读取的缓存數据。<br />
偶尔数据库层因为有事务机制，所以在默认情况下是并发安全的.程序员只需确保事务在每个业务服务的开头创建，在业务服务结束时提交.<br />
----

= 第11章 可重用的设计模式 =
----
案例分析<br />
iCoot中的模式<br />
- 覌察器模式由GUI接口用于客户端(桌面和移动设备版本).这些接口使用两层模型，其中包括GUILayer和ControlLayer，所有向上的通信都在其Java版本中使用現察器模式：事件委托. 在事件委托中，所有的通知都采用给监听器发布事件广播的形式.一些事件传送属性值中的变化，一些纯事件，如“登录成功”，不传送.
- 单一模式用于服务器端，其中每个实体有一个home,以管理实体的创建和奎找.一些home 也有一般实用方法，例如 carModelHome.findEngineSize()。
- 不使用多重模式.Java的语法中最近添加了多重模式，但使用int类里的公共类常量仍比较普遍，例如CarColor.MIDNIGHT_BLUE(类常量是只读的(如final)类字段).
- 迭代器模式在客户机和服务器上用于访问List对象。
- 工厂方法在客户机和脹务器上使用广泛.例如，业务层需要创建包含数据库中数振的实体时，就使用 home 中的工厂方法：CustomerHome.getlnstance0.create(“Fred Bloggs", ,,02723359853,,,0).
- 不使用抽象工厂模式，但是实际上，home可以继承自一个常见的超类。
- 状态模式用于表示Reservation的状态机.
----

= 第12章 指定类的接口 =
== 12.1 引言 ==
* 为何编写规范:
	- 刪除早期阶段遗留下来的模糊性内容：模糊性内容表示制品可以以多种方式理解。
	- 加深对实现方案的理：
	- 提高对系统能工作的自信心 规范可以在我们付诸实践之前找出错误。
	- 有助于调试软件：软件出错时，可以检査实现代码是否匹配规范。因此，我们就有了识别和更正错误的起点。
	- 有助于测试软件：规范描述了软件的执行方式，测试可以验证软件是否按规范描述的那样操作。因此，测试可以用于检査软件是否符合规范。基于系统用例的测试可以验证生成的系统是否满足系统痛求。基于规范的测试对于库、模式、框架和可重用对象来说是必不可少的，因为这些都没有涉及实际的系统。
	- 有助于修改软件：如果决定以某种方式修改系统一例如添加功能，就可以检査这些修改是否违反了规范。
	- 允许把已实现的任务交给其他开发人员：尽管其他开发人员仍会与我们联系，以澄清细节，但他们将较少需要这么做。
	- 提供更好的文档说明：更好的文档说明将使系统更易于维护，重用性更好，误用的机会更少。

== 12.2 规范的定义 ==
* 规范是对软件所需的行为进行完整, 清晰的描述.
* 规范描述了一个或多个边界.
* 如果每个边界一端有一个客户, 另一端有一个提供者, 则规范描述如下:
	- 客户可以通过边界传送什么信息，它们何时可以传送信息。例如，客户只能在事务开始后，给顾客对象传送新地址信息。
	- 客户可以从边界上检索什么信息，它们何时可以检索信息。例如，客户只能在登录后，从图书服务器上检索要销售的图书列表。
	- 事件何时广播给已注册的客户，客户会接收到什么信息。例如，在分布式聊天系统中，每个客户都会获知每个进入聊天室的新客户名。
	- 边界管理的信息的合法状态。例如，集合对象可能会声明，它从来不会包含负的对象数。大多数情况下，规范关注的都是软件的公共边界。但是也可以指定内部边界的性质。例如.考虑个函数库，它为集合结构提供了排序功能。这个库有一个可重用的swap函数，用于交换集合中的两个值。swap函数不可能是排序库的公共接口的一部分，因为它是一个具体的实现细节：但是，仍可以指定它的行为一例如可以指定，在调用该函数后，左边的值会占据右 边的值以前占据的位置，而右边的值会占据左边的值以前占据的位置。
* 规范有两个变体：正式规范是科学的、严格的，而非正式规范是实际的、局部的，但不是 没有用处。

== 12.3 正式规范 ==
* 提高可靠的一种方法是复制硬件或软件. 
* 提高可靠性的另一种方式是, 从数学上证明软件是正确的. 这需要三步:
	# 用数学语言生成一个正式规范, 描述软件如何动作.
	# 证明该规范是可行的.
	# 证明软件遵循规范.
* 正式规范语言有Vienna开发方法(VDM)和对象约束语言(OCL).
* 例如, 为squareRoot()函数的行为编写正式规范.
	- 输入值必须是正的(假定非复数).
	- 结果的平方等于输入值.
	- 结果是正的.
* 使用VDM指定squareRoot()函数的边界条件:
{{{c++
	squareRoot(x:R)y:R
	pre >= 0
	post(y^2=x)∧(y>=0)
}}}
* 其中R表示实数, pre表示前提条件, post表示后置条件.
* 正式规范的生成和使用非常困难, 也很费时, 所以它们一般只用于安全性要求很高的系统和需要非常可靠的技术的系统.

== 12.4 非正式规范 ==
* 所有的程序员都在某种程度上使用非正式规范----给函数添加注释，便于其他程序员理解就是一个简单的例子。函数注释描述了下述列表中的一些或所有信息：
	- 客户何时可以调用函数
	- 应传送什么参数
	- 函数完成什么任务
	- 返回什么结果(类型和值〉
	- 函数对全局数据有什么影响
	- 如果出问题，函数会采取什么措施
* 这些信息也可应用于子例程、过程和方法，因为这些都是函数的变体。
* 通常，函数注释不会提及内部的实现方式——与规范的其他形式一样，注释只描述边界上的条件。注释偶尔也会提及实现方式，但仅在必要时提及，且使用抽象的术语来说明。例如， 客户程序员知道某个sort函数的时间/空间折衷方案是很有用的，例如“这个函数的执行速度 是nlogn,需要2n的内部空间来处理”。
{{{c++
/*
	Return the positive squre root of x.
	Preconditions: x >= 0
*/
float squareRoot(float x);
}}}
* 大多数程序员都很熟悉“前提条件”这个术语，或者很容易理解它。如果要获得最大的可靠性，就可以使用“要求”来替代“前提条件”，用“确保”替代“后置条件”，或者用自然语言编写前提条件和后置条件。上述非正式规范是不完整的，这与前面给出的正式VDM版本不同：例如，我们没有说过结果的平方等于参数。
* 本书前面提及的另一种非正式规范是用例。每个用例都描述了下述信息的部分或全部
	- 何时可以使用用例(前提条件）
	- 用例做什么工作(步骤和后置条件）
	- 用例对系统有什么影响(步骤和后置条件）
	- 在异常情况下会发生什么

== 12.5 动态检查 ==
* 非正式规范包含一种实际的技术，称为动态检查。动态检査是嵌在实现方式中的代码.可以验证软件正在执行(例如它没有违反规范)。为了说明动态检査的工作原理，考虑平方根函数。
{{{c++
	/*
	Returns the positive square root of x.
	Preconditions: x>=0.
	*/
	float squareRoot(float x) { if (x < 0) {
	fail squareRoot", "Parameter x can't be negative");
	}
	.../* Code to calculate y */ return y;
	}
}}}
* 在这个函数中，有一段代码检杳前提条件x>0是否满足---如果不满足，函数就退出。 为了方便，提供了一个fail函数，输出函数名和错误消息，然后终止程序(使用C库函数exit)。 (一些语言提供了更优雅的方式，使用异常处理来发出失敗的信号，但功能变化得太多了)， 
* 客户程序员现在有了保护：在大多数情况下，客户用一个正数调用squareRoot,函数会成功完成.但是，偶尔客户会用一个负数调用squareRoot,此时程序不会继续执行，直到更正了错误为止。
* 动态检査只对非正式规范有意义，对正式规范没有意义。
* 在squareRoot的例子中，如果把最大的可能错误值封装在一个函数squareRootError中，再访问pos函数，pos返回其参数的正数部分，就可以指定“对于结果y, pos((y*y)-x)<= squareRootErrorO)”。这个规范可以添加到函数注释中，在最后编码为一个检查：
{{{c++
	/*
		Returns the positive square root of x.
		Preconditions: x>=0.
		Postconditions: For result y,
						(y>=0) and pos((y*y)-x)<= squareRootError()).
	*/
	float squareRoot(float x) { 
		if (x < 0) {
			fail("squareRoot", "Parameter x can't be negative");
		}
	...
	/* Code to calculate y */ 
	if (y < 0) {
		fail("squareRoot", "Calculation gave negative result");
	}
	if (pos( (y*y) -x)> squareRootError ()){
		fail("squareRoot", "Calculation cas inaccurate");
		}
	return y;
	}
}}}
* 现在不只确保客户程序员在他们的代码中没有错误，还保证在我们的代码中没有错误。
* 如果不能为最大的可能错误计算出一个值(或者觉得这太麻烦)，就应把规范以自然语言添加到注释中：
{{{c++
	...
	The square of the result is equal to x,
	subject to the accuracy of the current platform.
}}}

== 12.6 面向对象的规范 ==
* 面向对象的规范语言必须可以断言：
	- 消息何时可以合法地传送给一个对象(消息前提条件，用公共属性表示）
	- 每个消息的有效参数(消息前提条件）
	- 消息对接收对象的影响(消息后置条件，用公共属性表示）
	- 每个消息的有效回应(消息后置条件）
	- 对象总是满足的条件(类不变式(class invariant),对类的实例总为真的条件，用公共属性表示）
* 除了对象、对象属性、对象消息之外，还有类、类属性和类消息;所以，上述五类也可以应用于类.但通常很难从表示法上看出其区别。
* 例如，考虑Container类和add消息。假定要断言：
	- 前提条件：传送给add消息的对象引用必须不为空。
	- 前提条件：传送给add消息的对象必须不在Container中。
	- 后置条件：在add消息之后，Container中的对象比以前多一个。
	- 后置条件：在add消息之后，Container包含作为一个参数传入的对象。
	- 不变式：Container包含的对象数总是正的。
* 在下面两节中，将探讨如何在OCL(正式规范语言)和Eiffel(一种指令性编程语言，包含非 正式规范的语法)中表达Container断言。

=== 12.6.1 OCL中的正式规范 ===
* OCL是UML的正式规范语言, 很适合把UML用作表示法的面向对象方法.
* 其中contains方法只有在接收器包含o时才返回true:
{{{c++
	context Container::
		add(o::Object)
			pre: (o<>null) and not contains(0)
			post: contains(0) and (size = size@pre+1)
	context Container::
		inv: size>=0
}}}
* OCL允许使用context关键字把断言连接到一个类上，这表示对于复杂的语言，如C++,也可以在规范中引用全局函数和全局数据。后置条件常常需要在执行方法之前指定属性值——这就允许讨论方法对接收器属性的影响。在本例中，size@pre表示在执行add之前size的值。
* 文字理解: 在给Container发送add消息时，参数o必须是非空的，o不能已在Container中.一旦方法执行完，Container就包含0，Container的大小比执行方法之前大1. Container的大小总是大于或等于0.

== 12.6.2 Eiffel中的非正式规范 ==
* Eiffel是用非正式的、可动态检查的规范设计的。Eiffel程序员可以把断言放在源代码中，但与注释和实现代码分开：断言由Eiffel编译器识别为语法的一部分。Eiffel使用require关键字代替pre,用ensure 替代post,用old替代@pre?对于Container例子，可以使用下面的Eiffel片段：
{{{c++
	classs CONTAINER
		feature {ANY} .-Public stuff follows
			size : INTEGER
			add(0:OBJECT) is
				require
					(o != void) and not contains(o)
				do
					...
				ensure
					contains(0) and (size = old size + 1)
				end
		invariant
			size >= 0

		end
}}}

== 12.7 按合同涉及 ==
* 在按合同设计时，要假定客户对象和提供者对象之间建立了一个合同，对双方进行了约束。其理念是，只要客户履行了其义务，提供者就也要履行其义务(如图丨2-2所示)。
{{{c++
// Beryl的foo方法:
void foo () {
	...
	if (! ... check aSupplier ...) { fail("Invalid state of a supplier");
	}
	if (!... check anObject ...) { fail("Invalid parameter for a supplier message");
	}
	int result = aSupplier.bar(anObject);
	if (!... check result ...) { fail("Invalid result from a supplier message");
	}
	if (!... check aSupplier...) { fail ("Invalid state of .a supplier");
	}
	...
}

public int bar(Object anObject){ 
	if (!... check this object...) { fail("Invalid state of this object");
	}
	if (!... check anObject...) { fail("Invalid parameter from a client");
	}
	int result =...
	if (!... check result ...) { fail("Invalid result for a client");
	}
	if (!... check this object...) {
		fail("Invalid state of this object");
	}
	return result;
}}}
* 使用正式的规范术语，可以准确地表述合同约定的义务
	- 客户必须遵循提供者的不变式。
	- 使用提供者方法要满足其前提条件。
	- 提供者方法的实现代码必须保证其后置条件。
	- 提供者方法的实现代码必须保证提供者的不变式。
* 在方法完成其任务时，可以违反合同，只要在任务完成时满足合同的要求即可。例如，如果Supplier不变式是a+b=4,且在调用bar时两个属性值都是2, bar就可以把a设置为10,把6设置为-6:但是，在大多数编程语言中都不能同时设置两个值，所以在bar中a+b有一段时间是12或-4。
* 类也可以有内部的合同，对于非公共属性，其形式是不变式，对于非公共方法，其形式是前提条件和后置条件。内部合同对实现代码和维护代码的人都很有利，但其重要性不如外部合同.

=== 12.7.1 合同与继承 ===
* 面向对象编程支持继承，所以应考虑继承对合同的作用。由于多态性的存在，从客户的角度来看，必须保证每个子类合同与其超类合同一样好，或比其超类合同更好。没有这个规则，程序员就可能通过超类变量来使用子类变量。
* 沿着类层次结构向下，类不变式将使用and来合并：只能向不变式中添加内容。例如，如果类X有不变式i1,子类Y添加了不变式i2,则Y的总不变式就是il and i2。其含义是，为 属性提供了额外的保证?
* 只有在子类中重新定义相关的方法，前提条件和后置条件才会成为一个问題。对于前提条件，必须确保重新定义的方法至少要接受它在超类中接受的所有消息：只能弱化(weaken)前提条件。因此，给重定义方法添加的任何前提条件都使用or与继承方法上的前提条件合并。例 如，如果foo有一个前提条件pre!,子类添加了前提条件pre2,则结果就是，重定义方法的前 提条件就是pre1 or pre2?
* 对于后置条件，必须确保每个子类都至少与其超类有相同的后置条件；只能强化(strengthen) 后置条件。因此，后置条件使用and来合并。例如，如果foo的后置条件是postI,子类添加了后置条件post2,重定义方法的后置条件就是postl and post2?
	- 如果省略了不变式，就表示“这个类不需要保证什么”：如果超类上没有不变式，而给子类添加了-个不变式，结果就是添加给子类的不变式。
	- 如果省略了前提条件，就表示“这个消息可应用于所有的情况”;如果重定义方法原来没有前提条件，现在给它添加了一个前提条件，新的前提条件将不起作用(不能弱化能接受任何消息的方法)。
	- 如果省略了后置条件，就表示“这个消息不能保证什么”;如果重定义方法原来没有后置条件，现在给它添加了一个后置条件，结果就是添加重定义方法的后置条件(添加 的任何内容都会强化后置条件)。
{{{c++
// Beryl
void  foo()  {
	...
	if  (  !  ...  check  aSupplier’s  invariants  ...  )  {
		fail("Invariants  broken  for  a  supplier");
	}
	if  (!  ...  check  bar’s  preconditions  ...  )  {
		fail("Preconditions  broken  for  a  supplier  message");
	}
	int  result  =  aSupplier.bar(anObject);
	if  (!  ...  check  bar’s  postconditions  ...  )  {
		fail("Postconditions  broken  by  a  supplier  method");
	}
	if  (!  ...  check  aSupplier’s  invariants  ...  )  {
		fail("Invariants  broken  by  a  supplier  method");
	}
...
}

// Fred
public  int  bar(Object  anObject)  {
	if  (!  ...  check  invariants  ...)  {
		fail("Invariants  broken");
	}
	if  (!  ...  check  preconditions  ...)  {
		fail("Preconditions  broken");
	}
	int  result  =  ...
	if  (!  ...  check  postconditions  ...)  {
		fail("Postconditions  broken");
	}
	if  (!  ...  check  invariants  ...)  {
		fail("Invariants  broken");
	}
	return  result;
}
}}}

=== 12.7.2 减少错误检查代码 ===
* 按合同设计的主要优点是把客户的责任和提供者的责任淸晰地分开?在发送bar消息之前,客户在控制之下。于是，客户有责任保证在发送消息之前不违反合同。在执行方法时，提供者在控制之下。于是，提供者有责任保证在方法返回之前不违反合同。
{{{c++
// Beryl
void  foo()  {
	...
	if  (  !  ...  check  aSupplier’s  invariants  ...  )  {
		fail("Invariants  broken  for  a  supplier");
	}
	if  (!  ...  check  bar’s  preconditions  ...  )  {
		fail("Preconditions  broken  for  a  supplier  message");
	}
	int  result  =  aSupplier.bar(anObject);
	...
}

// Fred
public  int  bar(Object  anObject)  {
	int  result  =  ...
	if  (!  ...  check  postconditions  ...)  {
		fail("Postconditions  broken");
	}
	if  (!  ...  check  invariants  ...)  {
		fail("Invariants  broken");
	}
	return  result;
}
}}}
* 还可以使用按合同设计进一步减少检查代码。在许多情况下，我们编写的代码都不可能违反合同。例如，考虑下面Supplier的实现代码：
{{{c++
//  A  supplier
//  Invariant:  x  <  5
public  class  Supplier  {
	private  int  fieldX;
	/*
	Constructor
	*/
	public  X()  {
	fieldX  =  1;
}
/*  Getter  for  x
Preconditions:  true  (call  this  method  any  time)
Postconditions:  true  (no  side  effects)
*/
public  int  getX()  {
	return  fieldX;
}
/*  A  method
Preconditions:  o  !=  null
Postconditions:  For  result  r,  r  >  x
*/
public  int  bar(Object  o)  {
	fieldX  =  o.toString().length()  %  5;
	return  fieldX  +  1;
	}
}
}}}
* 在这个例子中，x表示UML样式的属性一x的值可以通过消息getx从外部访问。为了强调公共属性和私有实现代码之间的区别，字段有另一个名称fieldX。
* 从编写的方式来看，Supplier代码总是遵循不变式和后置条件：
	- 在创建Supplier后，x小于5,因为fieldX由构造函数设置为1。
	- 在执行getX后，x小于5,因为getX没有副作用。
	- 在执行bar后，x小于5，因为fieldX设置为被5除后的余数。
	- 在执行bar后，结果大于5,因为bar返回fieldX + 1。
* 由于Supplier不可能违反合同，因此不需要检查代码(原则上，平台失敗会违反合同，但为这种情况添加检查代码是不可行的)。
* 现在考虑Client上foo的下述实现代码：
{{{c++
void  foo()  {
Supplier  aSupplier  =  new  Supplier();
int  result  =  aSupplier.bar(new  Plate("Wedgwood"));
...
}
}}}
* 在发送bar消息时，foo不可能违反aSupplier的不变式，因为它没有触碰新对象的属性。另外，foo也不可能违反bar的前提条件，因为它传送的是非空对象。所以，foo不需要任何检査代码。最终，这个程序没有任何检査代码。
* 如果从当前的进程跳转到另一个进程或另一个硬件上，就可能出现不能控制的情况。进程中的错误可以通过履行合同(enforcing the contract)来处理，进程外部的错误可以通过构建应用程序防火墙(application firewall)来处理。

=== 12.7.3 履行合同 ===
* 按合同设计依赖于如下假定：只要客户对象履行了其义务，提供者就也要履行其义务.但程序员可能犯错误：有时义务也没有履行，所以需要动态检查，来检测错误。但由谁负责检査合同义务的雇行情况？如果检测到销误，又该怎么办？
* 在客户和提供者的例子中，bar方法应负责在返回前.检査前提条件和不变式，因为只有bar方法或其提供者才有可能在方法开头和结尾之间违反合同。所以，对合同中提供者部分的动态检查(后置条件和不变式)应在bar方法的最后进行。
* 在bar开始之前检査不变式和前提条件的问题要复杂一些。客户代码负责确保不违反合同 中的客户部分。但是，如果bar的每个客户都必须有检査合同的代码，这些代码就会在整个系统屮不断地重复。
* 面向对象理论指出，责任应赋予相关的对象。这说明，检查合同中的客户部分应是提供者提供的一个服务(因为前提条件和不变式与提供者相关)。所以，为了避免重复客户的合同检査代码，应把这些代码放在bar的开头。这有两种方式：bar阻止提供者在客户中犯错，或者bar 为客户提供一个服务，来检査它是否有错误(在按合同设计中，第二个解释比较好>。
* 把非正式方法、按合同设计、信任和动态检査合并起来，bar方法的Java实现代码如下所示：
{{{c++
public  int  bar(Object  anObject)  {
	if  (!  ...  check  invariants  ...)  {
		fail("Invariants  broken");}
	if  (!  ...  check  preconditions  ...)  {
		fail("Preconditions  broken");
	}
	int  result  =  ...
	if  (!  ...  check  postconditions  ...)  {
		fail("Postconditions  broken");
	}
	if  (!  ...  check  invariants  ...)  {
		fail("Invariants  broken");
	}
	return  result;
}
}}}
* 有了上述实现代码, 客户中就不需要合同检查代码了.

=== 12.7.4 应用程序防火墙 ===
* 超出进程外的东西:
	- 其他进程 
	- 操作系统 
	- 用户界面 
	- 文件系统 
	- 网络
	- 数据库 
	- 设备
* 可以在边界上构建一个应用程序防火墙，保护进程内部的代码，例如，用户界面防火墙可以在把用户数据传送给业务对象之前，检査这些数据的有效性，数据库防火墙可以捕获数据库错误(这与捕获内联网的Internet防火墙没有关系)
* 有时，可以防止无效数据进出应用程序防火墙。例如，如果用户必须输入用户名和密码才能登录，就可以在用户登录之前，在GUI上禁用Login按钮。

== 12.8 Java中的非正式规范 ==
=== 12.8.1 使用注释编写合同文档 ===
* 每个类都应在其顶部有一个很长的注释---类注释，它描述了类的作用和其公共属性的不变式。注意，査看源代码的其他程序员可能不熟悉正规的术语，所以应使用"对于这个类的所有对象，应用下面的条件"等词语。类注释还可以包含类如何使用的例子。
* 类上的每个公共消息都应在其顶部有一个注释---消息注释，它描述了对应方法的作用，列出了所有的前提条件和后置条件。为了便于不熟悉术语的读者阅读，应使用“要求(requires)” 和“保证(guarantees)”等词语，而不是“前提条件”和“后置条件”。
* 记住，在实现方法时，调用者应负责确保在调用方法之前，满足不变式和前提条件。换言之, 编码方式应是乐观的。当然，它的一个副作用是，应确保实现代码不违反后置条件或不变式。

=== 12.8.2 动态检查条件 ===
* 在原则上，最好在每个公共方法的开头添加+变式检査和前提条件检査，在公共方法的结尾添加后置条件检查和不变式检査。
* 最好在每个要多次重用的公共方法开头添加检査(例如代码用于一个库)。第三方可能会欣赏检杳代码提供的额外帮助，因为他们很熟悉类。
* 对于公共方法结尾的检查，就是一个个人喜好的问题了。如果方法不可能违反合同中的提供者部分，这些检查就是多余的。如果觉得代码可能违反合同，也许就不相信自己了：随着实现面向对象代码的经验的增长，自信心也会增加，这样，这些检査就会变成多余的了。
* 在方法结尾包含检查的惟一原因是，相信代码所涉及的第三方代码可能违反不变式，破坏属性：大多数代码都是在客户一服务器样式屮调用，所以这种情况并不常见。
* 只要选择屜行合同，就需要一种发出违反合同信号的干净利落的、优雅的方式。所以，应避免使用fail消息。但在对应fail方法的内部需要什么代码，才能优雅地失敗？ 一种选择是退出程序：在Java中，可以使用System.exit(-1)来退出程序。但是，这个技术会删除如何到达失败点的大多数信息一它只说明最后执行的那个方法，没有说明哪个方法调用了它。
* 除了己有的明确性之外，Java方法还可以抛出异常，向调用方法发出信号，说明当前方法不能继续执行下去。Java有一种特殊类型的异常，叫做RuntimeException,它可以用在这种情 形。RuntimeException用来说明方法因为实现代码或调用方法中的一个错误而不能继续执行下去。调用方法不会捕获RuntimeException,而是让运行时系统给它自己的调用方法重新抛出这个异常，在上一级的调用方法中，再为更上一级的调用方法重新抛出这个异常，最终，异常会到达进程的最外层，即main方法，它会暂停这个抛出过程中的所有方法。
* 在main抛出RuntimeException时，程序会被运行时系统停止，用户(或测试人员、管理员）可以通过失敗方法査看跟踪情况，其跟踪路线是：
{{{c++
RuntimeException  in  bar()  "Preconditions  violated"
	main()  called  foo()  on  Client
	foo()  called  bar()  on  Supplier
}}}
* 给违反合同发出信号的Java样式如下面的例子所示:
{{{c++
public  class  Supplier  {
	...
	//  Precondition:  o  !=  null.
	public  int  bar(Object  o)  {
		if  (o  ==  null)  {
		throw  new  RuntimeException("Preconditions  violated");
		}
	...
	}
	...
}
}}}
* 在较大的程序中运行Java代码时，例如在Web服务器中运行服务小程序，或者在GUI上运行业务组件.就不应让RuntimeException对象(或其他类型的异常倒达main方法，否则整个程序都会停止。程序边界上的一般代码可以捕获未处理的异常，并向管理员或用户报告异常。例如，Web服务器可以在系统曰志文件中添加错误报告，再给用户显示错误消息，例如“您的 请求不能完成，因为...”加上一些建议。

=== 12.8.4 外部系统 ===
* 在自己的进程中运行代码时，可以安全地禁用动态检査。相信自己的代码;相信同事的代码：相信模式、库和框架中的代码。仴是，仍需要构建应用程序防火墙，防止代码被外界破坏。应用程序防火墙代码从来不会关闭，甚至在测试后也不会关闭。外部系统可以分类为客户和提供者，下面看看如何处理它们。

==== 1. 外部客户 ====
* 来自外部客户的请求旨在业务对象，所以必须履行业务对象的合同。于是，应用程序防火墙应以业务对象的名义检査合同的客户部分。但是，合同的内容最好封装在业务对象内部(因为这是合同内容应在的位置)。把不变式和前提条件检査封装在业务对象的消息中，就可以解决这个两难问题。
* 例如，考虑下面的类：
{{{c++
//  Invariant:  i1
public  class  Foo  {
	public  boolean  invariantOK()  {
		...  //  Return  true  if  i1  is  okay
	}
	public  boolean  okForBar(s,  f)  {
		...  //  Return  true  if  s,  f  satisfy  p1
	}
}
}}}
* 应用程序防火墙中的代码可以提取出bar的参数值(例如从用户界面或服务小程序中)，使用Foo上的服务消息测试调用的bar是否有效，如下所示：
{{{c++
//  Application  firewall  code
if  (aFoo.invariantsOK()  &&  (aFoo.okForBar(s,  f))  {
	aFoo.bar(s,  f);
}
else  {
	...  //  Signal  error  to  client
}
}}}
* 还可以提供每个Foo消息的检查版本和非检査版本，例如bar和barWithChecks。这会把应用程序防火墙代码移到Foo中，作为客户的一个服务。这个方法的缺点是，即使消息的检查版本从来都不会使用，也要提供它们---只有对象从应用程序防火墙中调用时，才会使用它们。
* 另一个方法是，把消息的检査版本放在一个单独的类FooWithChecks中。这个方法比应用 程序防火墙中的代码好一些，但要提供可能从来不使用的整个类。

==== 2. 外部提供者 ====
* 从进程中跳出，以访问外部提供者时，必须检査外部提供者的状态和返回的信息。这里也可以使用应用程序防火墙的理念。但是，如果应用程序防火墙检测到一个错误，该怎么办？最初，应用程序防火墙是由某个客户代码调用的，当应用程序防火墙检测到一个错误时，就必须告诉客户代码有一个问题。为了避免出现结果代码或错误变量，最好抛出一个异常。但是.与“违反合同”的情形不同，不能让客户代码忽略这类异常一即使在没有错误的代码宁，外部问题也是可以预见的。所以，必须迫使客户处理这种情况?
* 为此，Java提供了第二类异常，由Exception类表示，编译器会迫使客户代码处理该异常。在Java中，Exception对象称为己检査的异常，因为编译器要求提供检査代码，而RuntimeException 对象称为未检査的异常，因为不霈要(或者不应该>提供检査代码。
* 为了向进程外部的提供者通知出现了错误，可以执行下面的代码：
{{{c++
public  class  ExternalResourceUser  {
	public  void  useResource()
		throws  Exception  //  Checked  exceptions  must  be  listed
		{
			...  //  Use  the  external  resource
			...  //  Detect  a  problem
			throw  new  Exception("External  resource  failure");
		}
	}
}}}
* 有了RuntimeException, 就可以使用Exception的子类, 例如更具体的 IOException.

=== 12.8.5 启用和金庸动态检查 ===
* 我们希望生成的软件在部署时不违反任何断言——如果没有违反断言，就不需要进行检査。另一方面，在开发过程中，希望常常违反断言。
* 有两种方法可以启用和禁用动态检査。
	- 第一种方法是使用运行时开关(使用命令行参数或环境变量)：如果开关是打开的，运行时系统就会进行检査；如果开关是关闭的，运行时系统就不进行检查。
	- 第二种方法是使用编译时开关，建立系统的两个版本，一个带有检査代码，一个没有检査代码。在这两种情况下，都有更多的选择：例如，可以禁用库代码中的所有后置条件检査或所有的检査。

==== 1. 实现编译时开关 ====
* 使用解释淸晰的技巧就可以瀲活编译时开关。首先，引入一个类，把开关的值存储为一个类常量(有固定值的类字段)。下面是这个类(其中final表示"常量"):
{{{c++
public  class  ContractSwitch  {
	public  static  final  DO_CHECKS  =  true;
	//  It’s  okay  to  have  a  public  field  if  it’s  final
}
}}}
* 现在，可以根据开关的值，把动态检查代码封装在if语句中，如下所示:
{{{c++
public  class  Supplier  {
	...
	//  Precondition:  o  !=  null.
	public  int  bar(Object  o)  {
		if  (ContractSwitch.DO_CHECKS)  {
			if  (o  ==  null)  {
				throw  new  RuntimeException("Preconditions  violated");
			}
		}
	...
	}
}
}}}
* 当编译器进入If (ContractSwitch. DO_CHECKS)语句时，会发现类常量是true,所以if语句中的内容总是会执行; 编译前提条件的检査，并包含在当前的构建体中。但是，外层的if语句不需要代码，因为它在执行时是多余的。其结果是与前构建体包含合同检査代码，但不包含检査开关的代码。
* 为了构建禁用检査的系统版本，要找出ContractSwitch类的定义，把DO_CHECKS设置为 false.并重新编译系统。现在，编译器遇到If (ContractSwitch. DO_CHECKS)语句时，就会认为，由于常量是false,所以外层的if语句总是失敗，无法保证执行其内部的代码。结果是构建出来的系统不包含检査代码和开关检査代码。
* 这个编译时开关技术是Java语言规范的一部分，所以它可用于所有的Java编译器。稍微 思考一下，就能看出如何使该技术更有选择性(添加更多的类常量)。Java编译器按照包来编译类，所以必须把ContractSwitch类添加到每个包中.

==== 2. 使用断言机制 ====
* Java的断言机制允许程序员插入像assert  != null这样的语句。于是，可以使用运行时开 关控制断言的开和关，例如断言的失畋是否应使程序自动停止。尽管使用的是运行时开关，但是Java实现方式也可能在开关关闭时，删除所有与断言相关的进程和性能开销。
* 传统上，编程语言中的断言机制用于履行合同，在任意点插入错误检査代码。根据Java断言机制的文档说明，它不应用于履行合同的客户部分。其原因是，一些检查非常重要，不能禁用(由于安全原因)?更好的方法是说明，一些驻留在应用程序防火墙中的检査是强制的，断言机制不应用于这些检査。这个方法与本章前面的内容兼容。
* 尽管断言机制为检査合同提供了开关式机制的所有特性，也不能把它用于检查合同。阅读说明文档的其他程序员不希望以这种方式使用它。另外，如果检查在运行期间失敗时断言是打开的，那么抛出的异常类型就是Error,而不是RuntimeException。Error是不可恢复的问题， 程序员不应试图处理它，例如运行时系统中的错误或内存耗尽。在断言机制抛出Error时，并不符合应用程序防火墙用RuntimeException对象发出信号的规则。
* 将来可能在Java中添加自动履行合同的功能，但现在最好使用编译时开关技术。

